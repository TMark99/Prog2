<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
        <title>EPAM: Bináris keresés és Buborék rendezés implementálása</title>
        <para>
            Egy java osztály implementálása, amely képes előre definált n darab egész szám tárolására. Ez az osztály 
            az alábbi funkcionalitásokkal rendelkezik:
        </para>
        <para>
	Elem hozzáadása a tárolt elemekhez.
        Egy tetszőleges egész számról megállapíja, hogy el van-e tárolva.
        Az eltárolt elemeket rendezni tudja és visszatérni a rendezett elemekkel.
	</para>
        <para>
            A porgram kód pedig a következő:
        </para>

        <porgramlisting language="java"><![CDATA[
            import java.util.Arrays;

            public class IntTarolo {
                
                int array[];
                int index;
                int size = 0;
                boolean sorted = true;
                
                public IntTarolo(int size){
                    
                    this.size = size;
                    this.array = new int[size];
                }
                
                public IntTarolo(int array[]){
                    
                    this.size = array.length;
                    this.array = array;
                    this.index = this.size;
                    this.sorted = false;
                }
            ]]></porgramlisting>
        <para>
            Az osztály változóinak létrehozása és konstruktorai.
        </para>


        <porgramlisting language="java"><![CDATA[
                public void add(int ertek) {
                    if( size <= index ) {
                        throw new IllegalArgumentException("Tele van.");
                    }
                    sorted = false;
                    array[index++] = ertek;
                }
            ]]></porgramlisting>

        <para>
            A függvény amely segitségével új elemeket tárolunk el.
        </para>

        <porgramlisting language="java"><![CDATA[
                public String taroltE(int ertek) {
                    if(!sorted) {
                        sort();
                    }
                    
                    int left = 0, right = size - 1;
                    
                    while(left <= right) {
                        int mid = left + ( right - left ) / 2;
                        
                        if(array[mid] == ertek) {
                            return "A(z) " + ertek + " benne van.";
                        }
                        
                        if(array[mid] < ertek) {
                            left = mid + 1;
                        } else {
                            right = mid - 1;
                        }
                    }
                    
                    return "A(z) " + ertek + " nincs benne.";
                }
                
                public int[] sort() {
                    for(int i=0; i < size - 1; ++i) {
                        for(int j=0; j < size - i - 1; ++j) {
                            if(array[j] > array[j + 1]) {
                                int temporary = array[j];
                                array[j] = array[j + 1];
                                array[j + 1] = temporary;
                            }
                        }
                    }
                    
                    sorted = true;
                    return array;
                }
                ]]></porgramlisting>
            <para>
                A bináris kereső függvény amely logikai értéknek megfelelően adja vissza, hogy egy elem tárolt-e vagy sem.
            </para>
            <para>
                A buborékrendezés alapján rendezést végző sort() fűggvény.
            </para>

            <porgramlisting language="java"><![CDATA[
                @Override
                public int hashCode() {
                    final int prime = 23;
                    int result = 1;
                    result = prime * result + Arrays.hashCode(array);
                    return result;
                }

                @Override
                public boolean equals(Object obj) {
                    if (this == obj) {
                        return true;
                    }
                    if (!(obj instanceof IntTarolo)) {
                        return false;
                    }
                    IntTarolo other = (IntTarolo) obj;
                    return Arrays.equals(array, other.array);
                }

                @Override
                public String toString() {
                    return this.getClass().getSimpleName() + ": " + Arrays.toString(array);
                }
                
            }
            ]]></porgramlisting>
        <para>
            A fölüldefiniálások, és beépített függvények optimalizálása a programra nézve.
        </para>

    </section>


    <section>
        <title>EPAM: Order of everything</title>

        <para>
            Olyan metódust fogunk ebben a feladatban megnézni, amely tetszőleges Collection esetén vissza adja az elemeket
            egy List-ben növekvően rendezve, amennyiben az elemek összehasonlíthatóak velük azonos típusú objektumokkal.
        </para>
        <para>  
            Ha ez a feltétel nem teljesül a futáskor syntax error-t eredményez.
        </para>

        <porgramlisting language="java"><![CDATA[
            import static org.hamcrest.MatcherAssert.assertThat;
            import static org.hamcrest.Matchers.equalTo;

            import java.util.Collection;
            import java.util.Collections;
            import java.util.List;
            import java.util.Set;
            import java.util.stream.Collectors;
            import java.util.stream.Stream;

            import org.junit.jupiter.params.ParameterizedTest;
            import org.junit.jupiter.params.provider.Arguments;
            import org.junit.jupiter.params.provider.MethodSource;

            public class OrderOfEverythingTest {

                @ParameterizedTest
                @MethodSource("collectionsToSortDataProvider")
                public void testOrderShouldReturnExpectedListWhenCollectionIsPassed(Collection<Integer> input, List<Integer> expectedOutput) {
                    // Given as parameters

                    // When
                    // createOrderedList(List.of(new OrderOfEverythingTest()));
                    // ^ ez piros, az OrderOfEverythingTest nem implementálja a Comparable<OrderOfEverythingTest> -et
                    List<Integer> actualOutput = createOrderedList(input);

                    // Then
                    assertThat(actualOutput, equalTo(expectedOutput));
                }

                private static Stream<Arguments> collectionsToSortDataProvider() {
                    return Stream.of(
                        Arguments.of(Collections.emptySet(), Collections.emptyList()),
                        Arguments.of(Set.of(1), List.of(1)),
                        Arguments.of(Set.of(2,1), List.of(1,2))
                    );
                }

                private <T extends Comparable<T>> List<T> createOrderedList(Collection<T> input) {
                    return input.stream()
                        .sorted()
                        .collect(Collectors.toList());
                }
            }
        ]]></porgramlisting>

            <para>
            A következő sor syntax errort eredményez:
        </para>
        <porgramlisting language="java"><![CDATA[ 
            List<Integer> actualOutput = createOrderedList(input);
            ]]></porgramlisting>
    </section>


    <section>
        <title>EPAM: HashMap implementáció</title>

        <para>
            Egy java.util.Map implementáció, mely nem használja a Java Collection API-t.
            Az implementáció megfelel az összes megadott unit tesztnek, nem tud kezelni null
            értékű kulcsokat és a “keySet”, “values”, “entrySet” metódusok nem kell támogatják az elem törlést.
        </para>
        <para>
            Hash map használatához utánanézés szükségeltetik.
        </para> 
        <para>
            Azt,hogy működjön minden unit tesztre, a C++-ból jól ismert template osztályként definiálással érjük el. 
        </para>

        <porgramlisting language="java"><![CDATA[
            class ArrayMap<K, V> implements Map<K, V> {

            private static final int INITIAL_SIZE = 16;
            private static final String NULL_KEY_NOT_SUPPORTED = "This Map implementation does not support null keys!";

            private int size = 0;
            private K[] keys = (K[]) new Object[INITIAL_SIZE];
            private V[] values = (V[]) new Object[INITIAL_SIZE];

            @Override
            public int size() {
                return size;
            }

            @Override
            public boolean isEmpty() {
                return size <= 0;
            }

            @Override
            public boolean containsKey(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                return searchItemInArray(key, keys, Object::equals) != -1;
            }

            @Override
            public boolean containsValue(Object value) {
                int valueIndex = searchItemInArray(value, values, Object::equals);
                return valueIndex > -1 && keys[valueIndex] != null;
            }

            @Override
            public V get(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);
                if(size <= 0) {
                return null;
                }

                int keyIndex = searchItemInArray(key, keys, Object::equals);
                if (keyIndex > -1) {
                return values[keyIndex];
                }

                return null;
            }

            @Override
            public V put(K key, V value) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                int keyIndex = searchItemInArray(key, keys, Objects::equals);
                if (keyIndex < 0) {
                keyIndex = findFirstEmptyPlace();
                if (keyIndex < 0) {
                    expandArrays();
                }
                keyIndex = size;
                }

                V prevValue = values[keyIndex];

                keys[keyIndex] = key;
                values[keyIndex] = value;
                size++;

                return prevValue;
            }

            @Override
            public V remove(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                int keyIndex = searchItemInArray(key, keys, Object::equals);
                if (keyIndex > -1) {
                V prevValue = values[keyIndex];

                keys[keyIndex] = null;
                values[keyIndex] = null;
                size--;

                return prevValue;
                }

                return null;
            }

            @Override
            public void putAll(Map<? extends K, ? extends V> m) {
                m.forEach(this::put);
            }

            @Override
            public void clear() {
                Arrays.fill(keys, null);
                Arrays.fill(values, null);
                size = 0;
            }

            @Override
            public Set<K> keySet() {
                Set<K> result = new HashSet<>();
                for(K i : keys) {
                if (i != null) {
                    result.add(i);
                }
                }

                return result;
            }

            @Override
            public Collection<V> values() {
                Collection<V> result = new ArrayList<>();
                for(V i : values) {
                if (i != null) {
                    result.add(i);
                }
                }

                return result;
            }

            @Override
            public Set<Entry<K, V>> entrySet() {
                Set<Entry<K, V>> result = new HashSet<>();
                for(int i = 0; i < keys.length; ++i) {
                K key = keys[i];
                if (key != null) {
                    V value = values[i];
                    result.add(new AbstractMap.SimpleEntry<>(key, value));
                }
                }

                return result;
            }


            private <I> int searchItemInArray(I item, I[] array, BiPredicate<I, I> equalFunction) {
                for (int index = 0; index < array.length; index++) {
                if (equalFunction.test(item, array[index]))
                    return index;
                }

                return -1;
            }

            private int findFirstEmptyPlace() {
                return searchItemInArray(null, keys, Objects::equals);
            }

            private void expandArrays() {
                int expandedSize = size * 2;

                keys = Arrays.copyOf(keys, expandedSize);
                values = Arrays.copyOf(values, expandedSize);
            }

            }
        ]]></porgramlisting>

        <para>
            Több beépített függvényt felüldefiniálunk és a benne lévő tipusokat a K és V templates tipusokra cserélünk.
        </para>
    </section>


    <section>
        <title>Perceptron osztály</title>

        <para>
            A Perceptron a neuron idegsejt megfelelője a mesterséges inteligenciában. 
            Ezt tanulásra szokták alkalmazni, ugyanis képes feldolgozni és mintákat
            megtanulni, tehát a bemenetet is, ami 0,1 bol áll.
        </para>

        <para>
            Megoldás forrása:
                <link xlink:href=""></link>
        </para>

        <porgramlisting language="java"><![CDATA[
            #include <iostream>
            #include "mlp.hpp"
            #include "png++/png.hpp"

            int main (int argc, char **argv) {

                png::image <png::rgb_pixel> png_image (argv[1]);
                int size = png_image.get_width()*png_image.get_height();

                Perceptron* p = new Perceptron(3, size, 256, 1);

                double* image = new double[size];

                for(int i {0}; i<png_image.get_width(); ++i)
                    for(int j {0}; j<png_image.get_height(); ++j)
                        image[i*png_image.get_width()+j] = png_image[i][j].red;

                double value = (*p) (image);

                std::cout << value << std::endl;

                delete p;
                delete [] image;
            }
        ]]></porgramlisting>

        <para>
            A program elején szükségünk lesz három darab könyvtárra. 
        </para>

        <para>
            Szokásosan az iostream-et. Aztán a megjelenítés miatt az mlp.hpp re a perceptron miatt lesz szükség, 
            míg a png++/png.hpp a png formátumú képpel való munka miatt kell.
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                
