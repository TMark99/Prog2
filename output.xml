<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Írd meg a saját programozás tankönyvedet!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <honorific>Dr</honorific>
            <surname>Bátfai</surname>
            <firstname>Norbert</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>E. adjunktus, DE.</shortaffil>
            <jobtitle>Egyetemi adjunktus</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Információtechnológiai Tanszék</orgdiv>
            <address>
                <email>batfai.norbert@inf.unideb.hu</email>
                <email>nbatfai@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>Kassai út 26.</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
            <email>batfai.norbert@inf.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/">https://arato.inf.unideb.hu/batfai.norbert/</link>
            </otheraddr>
            </address>
    </author> 
<author>
        <personname>       
            <surname>Talinger</surname>
            <firstname>Mark-Imre</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>hallgató</shortaffil>
            <jobtitle>hallgató</jobtitle>
            <orgname>Debreceni Egyetem Informatikai Kar</orgname>
            <orgdiv>PTI</orgdiv>
            <address>
                <email>talingermark@gmail.com</email>               
            </address>
        </affiliation>               
    </author>    
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. február 19, v. 0.0.4</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Aktualizálás, javítások.
        </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>                  
                          
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Olvasgasd a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para><citation>KERNIGHANRITCHIE</citation></para>                        
                </listitem>
                <listitem>
                    <para><citation>BMECPP</citation></para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat: Egy végtelen ciklust rengetek modón meglehet határoni, a legegyszerűbb módja a for(;;). A mellett, hogy ez egyszerű, mások is egyértelműen érteni fogják, hogy oda végtelen ciklust szerettünk volna rakni.
A fordító a for-os és while-os ciklusból ugyanazt az assembly kódot fordítja, a for használata csak áltlahatóság és egyértelműség céljából ajánlot.
        </para>
        <para>
	A végtelen ciklusunk nem csak a meghatározásban, hanem a procceszor terhelésében is különbözhet, úgyan is leterhelhetjük azt, egyáltalán nem is zavarjuk meg vagy csak pár magot dolgoztatunk meg.
	</para>
	<para>
	0%-ban terhelhetjük a végtelen ciklusunkban a sleep függvényt is szerepeltetjük. Fontos megjegyezni, hogy a fűggvény használatához szükségünk van az unistd.h-ra.
	</para>
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	#include <unistd.h>
	int main()
	{
		while(1)
		{
		sleep(100);
 		}
	}
	]]></programlisting>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/nulla.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
	<para>
	Látható, hogy az a.out az az a programunk, nem terheli a proceszort.
	</para>
	<para>
	Egy magot 100%-ban dolgoztatni nagyon egyszerű, mivel semmi egyébre nincs szükségünk, mint leírni a végtelen ciklust.
	</para>
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	int main()
	{
		for(;;);
	}
	]]></programlisting>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/100.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
<para>
	Látható, hogy az a.out az az a programunk, csak az egyik magot terheli.
	</para>
	<para>
	Ha azt szeretnénk, hogy a végtelen ciklusunk minden magot dolgoztasson kicsit többet kell gépelnünk. Hozzá kell adjuk a #pragma omp parallel sort, amivel azt érjük el, hogy a folyamatott több magon futassa. használatához szükségünk van az omp-hra. (A fordításnál -fopenmp kapcsolóval kell bővítenünk a parancsot.)
	</para>
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	#include <omp.h>
	int main()
	{
		#pragma omp parallel
		for(;;)
	}
	]]></programlisting>
<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/mind.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
<para>
	Látható, hogy az a.out az az a programunk, minden magot terhel. Igaz a képen nem 100%-ban úgyan is az üres végtelen ciklus elé veszi azokat a programokat, amelyek ténylegesen "dolgoznak".
	</para>
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat: Ha úgy vesszük, hogy a T100 és T1000 létező program és T1000 ben meghívjuk saját magát. A t100 alapján ha a programunkba van végtelen ciklus, akkor igaz értéket ad a Lefagy program a Lefagy2 programnak ,így tehát az is igaz értéket fog adni, viszont ha a Lefagy false értéket ad vissza akkor a Lefagy2 belép egy végtelen ciklusba, vagyis a program le fog fagyni. Ebből következik, hogy olyan program, mint a T100 nem működik mivel, ha egy olyan program érkezik bele amiben van végtelen ciklus, akkor a program beáll mert a ciklus nem áll meg. 
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Napjainkba a számítógép fejlettsége és gyorsasága miatt, már egyszerűen megcsinálhatjuk egy segédváltozóval vagy exort-tal, de régen nagyon sokat számított az erőforrások jó felhasználása, elosztása. Ezekkel a megoldásokkal sokkal könnyebb volt a számítógépeknek számolni, ha különbséggel vagy szorzással cseréltük fel a változókat. Az utóbbi kettőt nézzük most meg.
        </para>
	<para>
            Változócsere különbséggel:
        </para>
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	#include <stdlib.h>
	int main()
	{
    		int a=1;
    		int b=2;
    		printf("%s\n%d %d\n","kulonbseggel:",a,b);
    		a=a-b;
		b=a+b;
		a=b-a;
    		printf("%d %d\n",a,b);
	}
	]]></programlisting>
	<para>
            A printf() függvény a kiíratáshoz használjuk. Az első argumentum a kíratás formátuma, a többi pedig a változók kiíratása. A „%d” azt jelenti, hogy egy egész típusú változót fogunk kiíratni, még a „\n” a sortörést.
        </para>
	<para>
            Változócsere szorzattal:
        </para>
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	#include <stdlib.h>
	int main()
	{
    		int a=1;
    		int b=2;
    		printf("%s\n%d %d\n","szorzassal:",a,b);
    		a=a*b;
    		b=a/b;
    		a=a/b;
    		printf("%d %d\n",a,b);
	}
	]]></programlisting>
	<para>
            A megoldás itt annyiban különbözik, hogy nem „+” és „–„ -t használunk hanem „*” és „/” -t.
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <curses.h>
#include <unistd.h>
int
main ( void )
{
    WINDOW *ablak;
    ablak = initscr ();
    int x = 0;
    int y = 0;
    int xnov = 1;
    int ynov = 1;
    int mx;
    int my;
    for ( ;; ) {
        getmaxyx ( ablak, my , mx );
        mvprintw ( y, x, "O" );
        refresh ();
        usleep ( 100000 );
        x = x + xnov;
        y = y + ynov;
        if ( x>=mx-1 ) {
            xnov = xnov * -1;
        }
        if ( x<=0 ) { 
            xnov = xnov * -1;
        }
        if ( y<=0 ) { 
            ynov = ynov * -1;
        }
        if ( y>=my-1 ) { 
            ynov = ynov * -1;
        }
    }
    return 0;
}
        ]]></programlisting>
        <para>
        	Forrás:<link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
	<para>
	A fejlécben azonal feltünik újdonság ként a curses.h header, amit azért használunk, hogy elérjük a képernyő kezelő fűggvényeket.
        </para>
	<programlisting language="c"><![CDATA[
    WINDOW *ablak;
    ablak = initscr ();
        ]]></programlisting>
        <para>
             Így hozzuk létre a kimenetet. Az initscr () függvény curses módba lépteti a terminált.
        </para>
        <para>
            A deklarált x és y -on lesz a kezdő értékünk. Az xnov és ynov pedig a lépésközt mutatja. (lépésenként a koordináta rendszeren xnov, ynov-al való elmozdulást). Az mx és my lesznek a határértékek, hogy a program csak az ablakon belül mozogjon és ne lépjen kibelőle. Ez az a határ ahol a labda visszapattan.
        </para>
        <para>
            A végtelen ciklus következtében, a labda addig pattog, amíg a program fút. A ciklusban az első függvény a getmaxyx (), ez határozza meg,hogy mekkora az ablakunk mérete. A refresh() függvénnyel frissítjük az ablakot, ezzel látjuk a labda mozgását, a frissítés nélkül a labda végig egy helyben állna a kijelzőn. Közöttük a mvprintw() függvény az x és y tengelyen megrazolja a „ „ között lévő szöveget, számot vagy karaktert, esetünkben az O-t. Az usleep függvény azt szabályozza mennyi ideig altassa a ciklust még újra indul, azaz milyen gyorsan mozogjon a labda. 
        </para>
        <programlisting language="c"><![CDATA[
        x = x + xnov;
        y = y + ynov;
        ]]></programlisting>
        <para>
        	Megnöveljük az értékeket, minden ciklus lefutásnál (mozog a "labda").
        </para>
	<para>
        	A kővetkező négy if-el pedig azt vizsgáljuk, hogy a labda az ablak szélén van e. Ha igen akkor -1 -el szorozzuk, ezáltal a labda irányt változtat. A fordításnál -lncourses kapcsolót kell használnunk.
        </para>
	<para>
        	Most nézzük meg a programot if-ek nélkül.
        </para>
	<para>
        	Forrás:<link xlink:href="https://progpater.blog.hu/2011/02/13/megtalaltam_neo_t">https://progpater.blog.hu/2011/02/13/megtalaltam_neo_t</link>
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <curses.h>
#include <unistd.h>
int
main (void)
{
    int xj = 0, xk = 0, yj = 0, yk = 0;
    int mx = 80 * 2, my = 24 * 2;
    WINDOW *ablak;
    ablak = initscr ();
    noecho ();
    cbreak ();
    nodelay (ablak, true);
    for (;;)
    {
        xj = (xj - 1) % mx;
        xk = (xk + 1) % mx;
        yj = (yj - 1) % my;
        yk = (yk + 1) % my;
        clear ();
        mvprintw (0, 0,
                  "--------------------------------------------------------------------------------");
        mvprintw (24, 0,
                  "--------------------------------------------------------------------------------");
        mvprintw (abs ((yj + (my - yk)) / 2),
                  abs ((xj + (mx - xk)) / 2), "X");
        refresh ();
        usleep (150000);
    }
    return 0;
}
        ]]></programlisting>
	<para>
        	Magyarázat: Az if-ek helyet megoldáshoz most szükségünk van matematikai számításokra, ehez deklarálunk egész tipusú változókat. A számításokat egy végtelen ciklusban számoljuk és mvprinw-vel íratjuk ki a képernyőre. A clear()-el minden egyes számítás előtt letisztítjuk az ablakot, ez azt csinálja, amit az elözőnél a refresh(). Az eslő kettő mvprintw-vel a felső és alsó határokat rajzoljuk ki, ebben a dobozban fog pattogni a labda. A harmadikkal pedig a "Labdát". Az Usleep függvény itt is a pattogás sebbeségét határozza meg.
        </para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
int main()
{
   int a=1;
   int bit=0;
   do
   bit++;	
   while(a<<=1);
   printf("%d %s\n",bit,"bites a szohossz a gepen");
} 
        ]]></programlisting>
         <para>
          Ez a program a gépünk szó hosszát fogja kiírni, azaz az <type>int</type> méretét.
          A feladatot a BogoMIPS ben használt while ciklus feltétellel írjuk meg (A BogoMIPS a processzorunk sebbeségét lemérő program amit Linus Torvalds írt meg). 
        </para>
        <para>
          A main függvényben az első sorban deklaráljuk a változót, amivel megvizsgáljuk a gépünk szóhosszát(int méretét).  A "bit" változó fogja a lépéseket számlálni. A programot dowhile ciklussal(hátultesztelős) írjuk meg, mivel a sima while nem számítaná bele az első lépést. Ha még is while-val szeretnénk megírni, a kiíratás előtt a végeredmény növelnünk kell eggyel. A ciklus addig fut amíg az "a" nem lesz egyenlő nullával. 
        </para>
	<para>
	Mi a bitshift operátor? Ugye vesszük az egyet. Ennek a bináris kódja a 0001, a bitshift operátor egy 0 -val eltolja, azaz 0010 kapjuk, ez a 2 szám, a count növekedik tehát az értéke 1 lesz.  A ciklus újra lefut és eltolja még egyszer a számot egy 0-val, így 0100 kapunk ami a négy.  Ez addig fut, még a gépünk szó hosszán (az int méretén) kívül nem tolja az 1-est. Ekkor a változónk értké 0 lesz. A ciklus befejeződik, és kiíratjuk hányat lépett. Ez a szám adja meg, hogy hány bites a szóhossz.
	</para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            A PageRank egy keresőmotor amit a Google használ. A programot két fiatal írta meg 1998-ban. Nevét az egyik kitalálója után kapta. 
        </para>
        <para>
        	A következőben, egy 4 lapból álló PageRank-at fogunk megnézni. A lapok PageRank-ét az alapján nézzük, hogy hány oldal osztotta meg a saját honlapján az oldal hiperlinkjét. 
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <math.h>
void
kiir (double tomb[], int db)
{
  int i;
  for (i = 0; i < db; ++i)
    printf ("%f\n", tomb[i]);
}
double
tavolsag (double PR[], double PRv[], int n)
{
  double osszeg = 0.0;
  int i;
  for (i = 0; i < n; ++i)
    osszeg += (PRv[i] - PR[i]) * (PRv[i] - PR[i]);
  return sqrt(osszeg);
}
int
main (void)
{
  double L[4][4] = {
    {0.0, 0.0, 1.0 / 3.0, 0.0},
    {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
    {0.0, 1.0 / 2.0, 0.0, 0.0},
    {0.0, 0.0, 1.0 / 3.0, 0.0}
  };
  double PR[4] = { 0.0, 0.0, 0.0, 0.0 };
  double PRv[4] = { 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0 };
  int i, j;
  for (;;)
    {
      for (i = 0; i < 4; ++i)
	{
	  PR[i] = 0.0;
	  for (j = 0; j < 4; ++j)
	    PR[i] += (L[i][j] * PRv[j]);
	}
      if (tavolsag (PR, PRv, 4) < 0.00000001)
	break;
      for (i = 0; i < 4; ++i)
	PRv[i] = PR[i];
    }
  kiir (PR, 4);
  return 0;
}
        ]]></programlisting>
        <para>
        	Forrás:<link xlink:href="https://progpater.blog.hu/2011/02/13/bearazzuk_a_masodik_labort">https://progpater.blog.hu/2011/02/13/bearazzuk_a_masodik_labort</link>
        </para>
	<para>
        	Kezdjük az új headerrel, ez a math.h. Ez tartalmazza a matematikai számításokhoz szükséges függvényeket. A main() fügvénnyben először is létrehozunk egy mátrixot, ami a lapok összeköttetését adja meg. Ha az érték 0 akkor a lap nincs összekötve az adott lappal és persze önmagával sincs. Ahol 1/2 vagy 1/3 az érték az azt jelzi, hogy az oldal hány oldallal van összekötve, például az 1/2: Az oldal 2 oldallal van összekötve és abbol az egyik kapcsolatot jelzi (az 1). 
        </para>
        <para>
        	A PR tömb fogja a PageRank értéket tárolni. A PRv tömb pedig a mátrixal való számításokhoz kell. A következő lépés egy végtelen ciklus.Ez majd a számítások végén a break parancsal megszakítjuk, ha a megadott feltétel teljesül. A for ciklusban van maga a PageRank számítása ami majd a tavolság függvényt is meghívja, ami egy részszámolást tartalmaz. A végtelen cikluson belül lévő ciklusok azért mennek 4-ig, mert 4 oldalt vizsgálunk. A ciklusból való kilépés a "break" parancsal történik, ha a tavolsag függvényben kapott eredmény kisebb mint 0.00000001. A végén a kiir függvény megkapja a PR értékeket és az oldalak számát és kiíratja azokat.
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
	 <para>
            A tételt Viggo Brun bizonyította 1919-ben. Ezért is nevezték el róla. A tétel kimondja hogy az ikerprímek reciprok összege a Brun konstanthoz konvergál, ami egy véges érték. Ikerprímeknek nevezzük azokat a prím számokat, melyek különbségének abszolút értéke kettő. Például a 3 és 5 vagy a 11 és 13.
        </para>
        <para>
        Brun tétel R szimulációban:
        </para>
        <programlisting language="c"><![CDATA[
library(matlab)
stp <- function(x){
    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}
x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
        ]]></programlisting>
	<para>
            A számoláshoz elősször is kell egy matlab könyvtár. A program fő része az stp függvény. Ez a függvény megkapja x-et. X egy határ szám lesz, ami megmondja meddig kell a prímeket megkeresni. Ehez a primes függvényt használjuk. A primes(x) kiírja x-ig az összes prímet. A diff vektorban eltároljuk a primes vektorban tárolt egymás melletti prímek különbségét. A számítást úgy végezzük, hogy a 2 prímtől indulva kivonjuk a prímből az előtte lévő prímet. Az idx el vizsgaljuk meg, hogy mely prímek különbsége 2 és ezek hol vannak (a helyüket a which függvény adja meg). a t1primes vektorban elhelyezzük ezeket a prímeket. A t2primes vektorba pedig ami ezeknél a prímeknél kettővel nagyobb (azaz ikerprímek). rt1plust2 vektorban végezzük a recikropképzést és a pár reciprokát összeadjuk. A returnban pedig a sum függvénnyel vissza adjuk ezek summázott összegét. Végezetül a plot függvénnyel lerajzoljuk grafikusan. 
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
	<para>
	A Monty Hall-paradoxon egy valószínűségi paradoxon. A lényege, hogy 3 ajóból kell választani, kettő mögött nincs semmi és a haramdik mögött egy értékes nyeremény. Az egészet az bonyolítja, hogy az ajtó kiválasztása után, a müsörvezető kinyítja az egyik ajtót ami nem nyert és felajánlja a váltást. A kérdés az, hogy megéri-e változtatni. A józan paraszti ész azt mondja, hogy nem. Matematikailag azonban az jön ki, hogy igen megéri. Lássuk a programt, ami leszimulálja a döntéseket.
	</para>
        <programlisting language="c"><![CDATA[
kiserletek_szama=10000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)
for (i in 1:kiserletek_szama) {
    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }
    musorvezeto[i] = mibol[sample(1:length(mibol),1)]
}
nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)
for (i in 1:kiserletek_szama) {
    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}
valtoztatesnyer = which(kiserlet==valtoztat)
sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)
        ]]></programlisting>
        <para>
        	Most a kisérletet 10000-szer fogjuk szimulálni. A kiserlet vektorban az első és a harmadik "ajtó" közül választunk 10000-szer. A replace=T-vel tesszük lehetővé, hogy egy eredmény többször is kijöhessen. A játékos valasztásait a jatekos vektornál ugyan így meghatározzuk.A sample() fügvénnyel végezzük a kiválasztást. A musorvezeto vektort a length függvényel a kisérletek számával tesszük egyenlővé. Következik a for ciklus ami 1-től a kisérletek számáig fut (10000). A ciklusban egy feltétel vizsgálat következik. Az if-fel megvizsgáljuk, hogy a játékos álltal választott ajtó megegyezik e a kisérletben szereplő ajtóval. Ha a feltétel igaz egy mibol vektorba beletesszük azokat az ajtokat, amiket a játékos nem választott. Az else ágon, ha a feltétel nem igaz ,akkor azt az ajtót eltároljuk, amit nem választott és amelyik a nyereményt rejti. A musorvezeto vektorban pedig azt az ajtót amit ki fog nyitni. A nemvaltoztat és nyer vektorban azok az esetek vannak, amikor a jatékos azt az ajtót választotta elsőre, ami mögött az ajtó van és nem változtat a döntésén. A valtoztat vektorban pedig azt, mikor megváltozatja a döntését és így nyer. Ezt egy forciklussal vízsgáljuk. A legvégén kiíratjuk az eredményeket, hogy melyik esetben hányszor nyert.  

        </para>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Forrás:<link xlink:href="https://slideplayer.hu/slide/2108567/">https://slideplayer.hu/slide/2108567/</link>
        </para>
        <para>
            Magát a gép fogalmát 1936-ban Alan Turing alkotta meg. A gép decimális számrendszerből unáris számrendszerbe írja át a számot. Az unáris számrendszer másnéven egyes számrendszer, lényege, hogy 1 eseket írunk csak. Ha az 1 számot akarjuk unárisba átváltani, az értéke egy, ha a 2-őt akkor az értéke 11, a tíz pedig 1111111111. A program c++ ban a következő:
        </para>
        <programlisting language="c"><![CDATA[
#include <iostream>
using namespace std;
int main()
{
	int a;
	int tiz=0, szaz=0;
	cout<<"Decimalis szam:\n";
	cin>>a;
	cout<<"A szam unarisban:\n";
	for (int i=0; i<a; i++){
		cout<<"1";
		++tiz;
		if (tiz==10) {cout<<" "; tiz=0;}
		if (szaz==100){cout<<"\n";szaz=0;}
	}
	return 0;
}
        ]]></programlisting>
        <para>
            A kód egyszerű. Bekérünk egy decimális számot "a"-ba, és egy forciklus segitségével addig irunk mindig egy 1-est amíg i(ami kezdetben 0 és mindig egyel növeljük) kisebb mint a. A kimenetett az olvashatóság szempontjából tizesével szóközzel, százasával pedig sortöréssel választja el a program az egyes kimeneti részeket.
        </para>
	<para>
	Állapot gráf:
	</para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/turing.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
        <para>
            Magyarázat az Állapotmenet grafikájának:           
        </para>
        <para>
            A gép beolvassa a memoríaszalag számjegyeit, (Az ábrán a szám a 10) ha elér az "=" ig, az előtte lévő számmal kezd el dolgozni, még az 0 nem lesz. Az első elem egy 0, de mivel a következő nem nulla, hanem 1 ezért ebből kivon 1 et, azaz hátulról a második elemet 0 ra állítja. a kezdő elem ami 0 volt, az pedig 9 lesz, és ebből mindig kivon egyet még 0 nem lesz, (8,7,6,5,4,3,2,1,0), minden kivonásnál kiírat sorban 1 est, így annyi 1 lesz, mint a decimális szám értéke. (Ha 100 lenne a szám akkor az 100 után 099 lenne aztán 098,097....089,088 és így megy 000 ig, és a kimeneten 100db 1 es lesz.) 
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            A generatív nyelvek kidolgozását Noam Chomsky nevéhez fűzzük. A nyelveket osztályba rendezzük. Vannak erősebb és gyengébb osztályok. Az erősebb osztály képes létrehozni gyengébb osztályt.
         </para>   
        <para>
           Négy darab alapon fekszik a generatív nyelvtan: 
        </para>
        <para>
           1.Terminális szombólumok. Azaz a konstansok. 
        </para>
        <para>
           2.Nem terminális jelek. Ezek a változók. 
        </para>
        <para>
           3.Kezdőszimbólum. Egy kijelőlt szimbólum.
        </para>
        <para>
           4.Helyettesítési szabályok. Ezzel szavakat értelmezzük majd.
        </para>
         <para>
            Forrás:<link xlink:href="https://slideplayer.hu/slide/2108567/">https://slideplayer.hu/slide/2108567/</link>
        </para>
        <para>
           1.nyelv               
        </para>
        <programlisting language="c"><![CDATA[
S, X, Y 
a, b, c 
]]></programlisting>
    <para>
        Az S, X, Y lesznek a változóink. Az a,b,c pedig a konstansok
    </para>
<programlisting language="c"><![CDATA[
S->abc, S->aXbc, Xb->bX, Xc->Ybcc, bY->Yb, aY->aaX, aY->aa
S (S->aXbc)
aXbc (Xb->bX)
abXc (Xc->Ybcc)
abYbcc (bY->Yb)
aYbbcc (aY->aa)
aabbcc
S (S->aXbc)
aXbc (Xb->bX)
abXc (Xc->Ybcc)
abYbcc (bY->Yb)
aYbbcc (aY->aaX)
aaXbbcc (Xb->bX)
aabXbcc (Xb->bX)
aabbXcc (Xc->Ybcc)
aabbYbccc (bY->Yb)
aabYbbccc (bY->Yb)
aaYbbbccc (aY->aa)
aaabbbccc
        ]]></programlisting>
        <para>
        Azt láthatjuk, hogy egészen addig alkalmazzuk a helyetesítési szabályokat még csak konstansaink lesznek. Azaz mindig alsóbb osztályt hozunk létre. 
    </para>
        <para>
            2. Itt a változók az A.B.C és a konstansok a,b,c. 
        </para>
<programlisting language="c"><![CDATA[
A, B, C legyenek változók
a, b, c legyenek konstansok
A->aAB, A->aC, CB->bCc, cB->Bc, C->bc
A (A->aAB)
aAB (A->aC)
aaCB (CB->bCc)
aabCc (C->bc)
aabbcc
de lehet így is:
A (A->aAB)
aAB (A->aAB)
aaABB (A->aAB)
aaaABBB (A->aC)
aaaaCBBB (CB->bCc)
aaaabCcBB (cB->Bc)
aaaabCBcB (cB->Bc)
aaaabCBBc (CB->bCc)
aaaabbCcBc (cB->Bc)
aaaabbCBcc (CB->bCc)
aaaabbbCccc (C->bc)
aaaabbbbcccc
        ]]></programlisting>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Ahogy a beszélt nyelv, úgy a programozási nyelv is fejlődik. Ennek a bemutatására az alábbi programot fogjuk használni:
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
int main(){
  for(int i=0;i<1;i++){
	printf("Lefut");
 }
}
        ]]></programlisting>
        <para>
            Itt ami lényeges, nem a kódban lesz, hanem a fordításnál. Megvizsgáljuk, hogy a C89 es nyelvtan  és a C99-es szerint hogyan fordítja le a programot a fordító. Ha a C89 es nyelvtannal fordítom: "gcc -std=gnu89 fajlnev.c -o fajlnev". A program hibát fog írni a for ciklusnál. Most ha a fordításnál átírjuk "gcc -std=gnu99 fajlnev.c -o fajlnev"-re (Azaz a fordító a 99 nyelvtan lesz) ,akkor láthatjuk, hogy lemegy a fordítás és a program működik.  A kódon belül, a for ciklusban deklaráltuk az <type>int</type>  i-t. 
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/c89c99.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
        <para>
            Magyarázat: Az okot a kódon belül, a for ciklusban kell keresni,ugyanis az "i" -t
            a forcikluson belül deklaráltuk. A C89 nyelvtanban ez még nem volt megengedett, így a fordító hibát írt, de a C99-ben már igen, ezért nem jelez hibát.
        </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            A program a bemeneten megjelenő valós számokat összeszámolja.
        </para>
        <para>
            A lexikális elemző kódja:
        </para>
        <programlisting><![CDATA[
 %{
 #include <string.h>
 int szamok=0;
%}
%% 		
[0-9]+		{++szamok;}
%%
int 
main()
{
 yylex();
 printf("%d szam",szamok); 							
return 0;
}
       ]]></programlisting>
        <para>
            A szamok változóval számoljuk hányszor fordul elő szám a bemenetben. A programot a % - jelekkel osztjuk fel részekre.
        </para>
       <programlisting><![CDATA[		
[0-9]+		{++szamok;}
       ]]></programlisting>
        <para>
            Ez a sor adja azt, hogy 0-9 karaktert talál akkor növelje a "szamok" valtozót. A printf-vel pedig csak kiíratjuk, hogy hány szám volt a bemenetben(ez az elemzés). A yylex() a lexikális elemző
        </para>
        <para>
            a fordítás a következő:
        </para>
            <programlisting><![CDATA[
flex program.l 
       ]]></programlisting>
        <para>
            ez készít egy "lex.cc.y" fájlt. ezt az alábbi módon futtatjuk.
        </para>
         <programlisting><![CDATA[
cc lex.yy.c -o program_neve -lfl
       ]]></programlisting>
        <para>
            A futtatáshoz pedig hozzá kell csatolni a vizsgált szöveget.
        </para>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <programlisting><![CDATA[
%{
 #include <string.h>
 int szamok=0;
%}
%% 		
"0"	{printf("o");}
"1"	{printf("i");}
"3"	{printf("e");}
"4"	{printf("a");}
"5"	{printf("s");}
"7"	{printf("t");}
"o"	{printf("0");}
"i"	{printf("1");}
"e"	{printf("3");}
"a"	{printf("4");}
"s"	{printf("5");}
"t"	{printf("7");}
%%
int 
main()
{
 yylex();
 printf("%d szam",szamok); 							
return 0;
}
       ]]></programlisting>
        
        <para>
         Ez a program lefordítja a l33t nyelven írt titkos szöveget vagy a rendes szöveget írja át a l33t nyelvre. Nem ismer fel minden leet szöveget, úgyan is a program minden számhoz, csak egy betűt rendel és tudjuk egy karaktert több féle képen is lehet leetelni. 
        </para>
        <para>
            A program müködése az előzővel majdnem megegyezik, csak annyiban tér el, hogy valós számok helyett, itt most a megadott számokat keresi a bemenetben és azok a számok helyett a l33t nyelvben való megfelelő betűket írja a helyére. Ha pedig a l33t nyelvre akarjuk fordítani, akkor a betűket vizsgálja és a megfelelő számot írja be.
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/lexer.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            <para>
			Ötször lefútt a for ciklus. Az i értéke a ciklus lefutása előtt változik.
			</para>
			</listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>   
			<para>
			Ötször lefútt a for ciklus, mint az előzőnél. Az i értéke a ciklus lefutása után változik.
			</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>   
			<para>
			Ötször lefútt a for ciklus, a vektor elemeinek 0-tól 4-ig veszik fel az értékeiket.
			</para>
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
			<para>
			Egy for ciklus ami addig fut le amíg eléri n-t és d indexértékét s indexértékéhez hasonlítja.
			</para>
            </listitem>
            <listitem>                                    
			
                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>
			<para>
            Egy kiíratás, ami az értékeket két függvényből várja.
            </para> 
            </listitem>
            <listitem>			

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>  
			<para>
            Egy kiíratás, ami kiír egy értékeket egy függvényből és egy változót.
            </para> 
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
			<para>
            Egy kiíratás, ami kiír egy értékeket egy függvényből és egy változót, a függvény most az a memóriacímével fog dolgozni.
            </para> 				
            </listitem>
        </orderedlist>
        <para>
            Tanulságok, tapasztalatok, magyarázat: Figyeljünk az operátorok használatára és az értékváltoztatások sorrendjére, úgyan is ezzek figyelmenkivül hagyása később nehézséget okozhat számunkra, például egy nem várt buggal esetleg helytelen érték visszatérítésével.
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 
$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 
$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 
$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat: 1 Minden x-re létezik egy nála nagyobb y ami prím.
			2. Minden x létezik egy annál nagyobb ikerprímszám.
			3. Van olyan y aminél minden x prím kisebb.
			4. Van olyan y aminél bármely nagyobb szám nem prímszám.
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>  
				<programlisting><![CDATA[int a;]]></programlisting> 
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>   
				<programlisting><![CDATA[int *b;]]></programlisting> 
            </listitem>
            <listitem>
                <para>egész referenciája</para>    
				<programlisting><![CDATA[int &r;]]></programlisting>
            </listitem>
            <listitem>
                <para>egészek tömbje</para> 
				<programlisting><![CDATA[int t[5];]]></programlisting>
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para> 
				<programlisting><![CDATA[int (&tr)[5] = t;]]></programlisting>
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>    
				<programlisting><![CDATA[int *d[5];]]></programlisting>
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para> 
				<programlisting><![CDATA[int *h();]]></programlisting> 
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para> 
				<programlisting><![CDATA[int *(*h) ();]]></programlisting>
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>
				<programlisting><![CDATA[int (*v (int c)) (int a, int b);]]></programlisting>
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>
				<programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting> 
			<para>
			Egy egész típusú változót.
			</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>
				<para>
				Egy egész típusú mutatót ami a-ra mutat.
				</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>    
				<para>
				a változónak a referenciája.
				</para> 
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>
				<para>
				Egy 5 elemű egész típusú tömböt.
				</para> 
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>   
				<para>
				Egészek tömbjének referenciáját.
				</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>
				<para>
				5 elemű int-re mutató mutatók tömbjét.
				</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>
				<para>
				Egy függvényt ami int-re mutató mutatót ad vissza.
				</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>
				<para>
				Egy int-re mutató mutatót visszaadó függvényre mutató mutatót.(pl. az előző függvényre)
				</para>	
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>
				<para>
				int-et visszaadó, két intet kapó függvényre mutató mutatót visszaadó egészet kapó függvényt.
				</para>
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>
				<para>
				int-et visszaadó, két intet kapó függvényre mutató mutatót visszaadó egészet kapó függvényre mutató mutatót.
				</para>
            </listitem>            
        </itemizedlist>       
    </section>                               

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>int ***</type> háromszögmátrix</title>
        <para>
         A következő programban egy alsó háromszögmátrixot hozunk létre.
        </para>
        <para>
            Forrás:<link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c">https://gitlab.com/nbatfai/bhax/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</link>
        </para>
	<para>
	Védési videó: <link xlink:href="https://www.youtube.com/watch?v=T_QqRdhgaP4">https://www.youtube.com/watch?v=T_QqRdhgaP4</link>
	</para>
        <programlisting language="c"><![CDATA[
	#include<stdio.h>
	#include<stdlib.h>
	int main()
	{
		int nr=5;
		double **tm;
		if ((tm=(double **)malloc(nr*sizeof(double)))==NULL)
		{
			return -1;
		}
		for(int i=0; i<nr; i++)
		{
			if((tm[i]=(double *) malloc ((i+1) * sizeof(double)))==NULL)
		  	{
				return -1;
	  		}
   		}
		for(int i=0; i<nr; i++) 
			for(int j=0; j<i+1; j++) 
	  			tm[i][j]=i*(i+1)/2+j; 
		for(int i=0; i<nr; i++) 
		{
			for(int j=0; j<i+1; j++)
	  			printf("%f,", tm[i][j]);
			printf("\n");
		}
		tm[3][0]=42.0;
		(*(tm+3))[1]=43.0;
		*(tm[3]+2)=44.0;
		*(*(tm+3)+3)=45.0;
		for(int i=0; i<nr; i++) 
		{
			for(int j=0; j<i+1; j++)
				printf("%f,",tm[i][j]);
			printf("\n");
		}
		for(int i=0; i<nr; i++)
			free(tm[i]); 
		free(tm); 
		return 0;
	}
        ]]></programlisting>
        <para>
            Magyarázat: Szokás szerint includoljuk a szükséges fejléceket. A fő függvény első sorában adjuk meg, hogy hány sorunk legyen "int nr=5", ezzel egy 5 soros háromszögmátrixot hozzunk létre. Az első if-ben megtaláljuk a malloc függvéynt, ami dinamikus memória foglaló, ezzel nr számú double ** mutatót foglalunk le. Ha null értéket ad vissza az azt jelzi, hogy nincs elég hely a foglaláshoz. A következő for lefoglalja a mátrix sorait, az első sornak egy double * mutatót foglal le, a másodiknak 2-t és így tovább, hogy meg legyen az alsó háromszögmátrix forma. A 3. for ciklussal megadjuk a mátrix elemeit. Az "i" a matrix sorai, a "j" pedig a benne lévő mutatók. 
A "tm[i][j]=i*(i+1)/2+j;" sorral érjük el azt, hogy az elemek mindig eggyel nőjenek. A 4. for ciklus a kííratás. A kiíratás után a harmadik sort megváltoztatjuk. Az érdekes ebben a program részben az, hogy a sor elemeire négy féle képen hívatkozunk, mind a négy felírás ekvivalens.A legvégén pedig a free()-vel felszabadítjuk a lefoglalt memóríát, ezzel megelőzve a memóriafolyást.
        </para>
	<para>
	Ha helyesen dolgoztunk ezt kell megkapjuk.  
	</para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/harom1.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
        <para>
	Érdekesség, hogy a double kicserélésével, bármilyen tipust használhatunk. A lenti képen a programban double helyet chart használtam. 
	</para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/haromchar.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>   
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            A feladat lényege a szöveg titkosítás Exor-ral(XOR). Az XOR a "kizáró vagy". A szöveget az alábbi módon titkosítjuk: az eredeti szöveg bájtjaihoz rendelünk titkosító kulcs bájtokat. Aztán XOR  műveletet végzunk rajta ami úgy müködik, hogy ha a bitek azonosak (1,1;0,0) akkor 0 ad vissza értéknek, ha pedig különbzözőek (1,0;0,1) akkor 1 et ad vissza. Minden bitpáron elvégezve ezt, megkapunk egy titkosított szöveget.
        </para>
        <para>
            Forrás:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux/ch05s02.html?fbclid=IwAR2X9zgwtSH6GW2_K67UrxjYDAVgljqV0i5KmBHuAaZ2DjWIvzyFW4LrCtA">https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux/ch05s02.html?fbclid=IwAR2X9zgwtSH6GW2_K67UrxjYDAVgljqV0i5KmBHuAaZ2DjWIvzyFW4LrCtA</link>
        </para>
        <para>
            Kód:              
        </para>
        <programlisting language="c"><![CDATA[
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#define MAX_KULCS 100
	#define BUFFER_MERET 256
	int main (int argc, char **argv)
	{
		char kulcs[MAX_KULCS];
		char buffer[BUFFER_MERET];
		int kulcs_index = 0;
		int olvasott_bajtok = 0;
		int kulcs_meret = strlen (argv[1]);
		strncpy (kulcs, argv[1], MAX_KULCS);
		while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
		{
			for (int i = 0; i < olvasott_bajtok; ++i)
			{
				buffer[i] = buffer[i] ^ kulcs[kulcs_index];
				kulcs_index = (kulcs_index + 1) % kulcs_meret;
			}
			write (1, buffer, olvasott_bajtok);
		}
	}
        ]]></programlisting>
        <para>
            Előszőr is deklaráljuk a szükséges fejléceket. Ezt követően két állandó változót határozunk meg a #define parancsal. Ezeknek az értéke nem változik, az az konstans értékek lesznek. Az első állandó a MAX_KULCS az értéke 100. A második a BUFFER_MERET 256, ez a beolvasásnál fog kelleni. A fő fügvényben egy-egy char tipusú tömb méreteivé tesszük a két állandót. Következőkben kétváltozót hozunk be, a kulcs_index, ami a kulcsunk aktuális elemét tárolja, és az olvasott_bajtok, ami a beolvasott bájtok összegét tárolja. A kulcs_merete változóban a kulcs méretét adjuk meg a "strlen()" függvény segítségével. A kulcsot mi adjuk meg az egyik argumentumként. Az strncpy függvény a kulcs kezeléséhez szükséges. A while ciklusban beolvassuk a buffer tömbe a bemenetet. A ciklus addig fut, ameddig van mit beolvasni. A read függvényel lépünk ki a ciklusból. A while cikluson belül a forciklusban végig megyünk az összes bájton és végre hajtjuk a titkosítást.
        </para>    
        <para> 
         	A futtatás a következő:
         	A fordítás:
         	gcc fajlnev.c -o fajlnev 
         	miután lefut, utánna futtatjuk: 
         	./fajlnev 56789012 (ez a kulcs) titkosítando.txt (ide írjuk a titkosítandó txt fajl nevét, relíciós jelek között) &gt; titkos.szoveg (titkosított fajlneve). A titkos szöveget a more titkos.szoveg parancsal nézhetjük meg.
         </para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Az előző feladatot fogjuk megírni Java-ban. A Java egy objektumorientált programozási nyelv,azaz a nyelv objektumokbol és osztályokból áll. A Sun Microsystems informatikai cég alkotta meg. Maga a nyelv a C és a C++ nyelvekhez hasonló, azonban sokkal egyszerűbb(az említett objektumorientáltság miatt). A kezdéshez beszéljünk kicsit az osztáylokról a "Class"-okról melyek egy függvények csoportja. Van public és private része, a publikus függvényeket a programból bármi meghívhatja, míg a private függvényeket vagy változókat csak az osztályon belüli vagy barát függvények hívhatják meg. 
        </para>
        <programlisting language="c"><![CDATA[
	public class ExorTitkosito 
	{
    
    		public ExorTitkosito(String kulcsSzoveg,
            		java.io.InputStream bejovoCsatorna,
            		java.io.OutputStream kimenoCsatorna)
            		throws java.io.IOException 
		{        
        		byte [] kulcs = kulcsSzoveg.getBytes();
        		byte [] buffer = new byte[256];
        		int kulcsIndex = 0;
        		int olvasottBajtok = 0;
        		while((olvasottBajtok = bejovoCsatorna.read(buffer)) != -1) 
			{            
            			for(int i=0; i<olvasottBajtok; ++i) 
				{
                			buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                			kulcsIndex = (kulcsIndex+1) % kulcs.length;
            			}           
            			kimenoCsatorna.write(buffer, 0, olvasottBajtok);         
        		}      
    		}
    		public static void main(String[] args) 
		{       
	        	try 
			{          
	            		new ExorTitkosito(args[0], System.in, System.out);            
	        	} 
			catch(java.io.IOException e) 
			{ 
	            		e.printStackTrace();         
	        	}      
  		}   
	}
        	]]></programlisting>
        <para>
        	Az ExorTitkosito() függvény, kapja meg a bekért argumentumokat. Ha rosszul kapja meg, a throw() hibát adja vissza. A függvény belsejében történik a titkosítás XOR-al. Ez ugyan úgy működik, mint a fenti C kódban. Ami érdekes lehet számunka az a byte típus, ez 8-bit. Byte tipusú lessz a kulcs és a buffer tömb is, ezek tárolják a kulcsot és a beolvasott szöveget.
        </para>
        <para>
            Vizsgáljuk meg a main függvényt. A Java nyelvben a main az osztály egyik függvénye (eltére a C++ -tol, ahol a main egy különálló fő függvény az osztálytól.) Az alábbi sor "public static void main(String[] args)" a függvény fejléce. A "public" mutatja, hogy publikus, azaz elérhető. A "static"-al jelőljuk, hogy része az osztálynak. A void típust meg már ismerjük az előzőkből. A main-be képesek vagyunk argumetnumokat bekérni a terminálból. Ezzen belül láthatjuk a try() és a catch() függvényt, ezekkel a függvényekkel C++ -ban, A try() a hiba üzenetet küldi még a catch() ezt elkapja és kiírja nekünk.            
        </para>
        <para>
            A fordításhoz java fordító kell. Ehez most a "javac"-t fogjuk használni. Ha ez nincs fent a számítógépünkön, akkor a gép jelezni fogja, hogyan kell telepítenünk.
            Fordítani és futtatni az alábbi módon fogjuk:
        </para> 
        <programlisting language="c"><![CDATA[
//Fordítás:
javac ExorTitkosító.java
//Futtatás:
java ExorTitkosító titkosítandó.szöveg > titkosított.szöveg
        ]]></programlisting>       
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Az alábbi feladatban a 3.2 feladatban lévő titkosítóhoz írunk egy programot ami feltöri a titkosított szöveget. A program alapműködése ugyan azon az elven alapszik, mint a 3.2 mivel ugyan úgy XOR-val alakítjuk vissza a szöveget. A lényeg, hogy a kulcsot amivel titkosítottunk azt ismerjük, mert ezzel a kulcsal tudjuk feltörni. Úgy működik, hogy a titkosított bájtokat össze exortáljuk a kulcsal, és így újra az eredeti bájtokat kapjuk. A feladatban a 3.2 ben titkosított azöveget és a kulcsot fogjuk használni, ugyanis erre épül a program.
        </para>
        <para>
            Kód:       
        </para>
        <programlisting language="c"><![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE
#include<stdio.h>
#include<unistd.h>
#include<string.h>
int tiszta_lehet(const char titkos[], int titkos_meret)
{
	return strcasestr(titkos,"hogy") && strcasestr(titkos,"nem") && strcasestr(titkos,"az") && strcasestr(titkos,"ha");
}
}
void exor(const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{			
	int kulcs_index=0;
	for(int i=0; i<titkos_meret; ++i) 
  	{
		titkos[i]=titkos[i]^kulcs[kulcs_index]; 
		kulcs_index=(kulcs_index+1)%kulcs_meret;
  	}
}
int exor_tores(const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{
	exor(kulcs, kulcs_meret, titkos, titkos_meret); 
	return tiszta_lehet(titkos, titkos_meret); 
}
int main(void)
{
	char kulcs[KULCS_MERET];
	char titkos[MAX_TITKOS];
	char *p=titkos;
	int olvasott_bajtok;
	while((olvasott_bajtok=read(0,(void *) p,(p-titkos+OLVASAS_BUFFER<MAX_TITKOS)? OLVASAS_BUFFER:titkos+MAX_TITKOS-p)))
		p+=olvasott_bajtok;
	for(int i=0; i<MAX_TITKOS-(p-titkos);++i)
		titkos[p-titkos+i]='\0';
	for(int ii='0';ii<='9';++ii)
 	 for(int ji='0';ji<='9';++ji)
	   for(int ki='0';ki<='9';++ki)
   	    for(int li='0';li<='9';++li)
    	     for(int mi='0';mi<='9';++mi)
              for(int ni='0';ni<='9';++ni)
      		for(int oi='0';oi<='9';++oi)
       		 for(int pi='0';pi<='9';++pi)
			{
			kulcs[0]=ii;
			kulcs[1]=ji;
			kulcs[2]=ki;
			kulcs[3]=li;
			kulcs[4]=mi;
			kulcs[5]=ni;
			kulcs[6]=oi;
			kulcs[7]=pi;
			if(exor_tores(kulcs,KULCS_MERET,titkos,p-titkos))
				printf("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",ii,ji,ki,li,mi,ni,oi,pi,titkos);
			exor(kulcs,KULCS_MERET,titkos,p-titkos);
			}
	return 0;		
}  
        ]]></programlisting>
         <para>
            Forrás:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux/ch05s02.html?fbclid=IwAR2X9zgwtSH6GW2_K67UrxjYDAVgljqV0i5KmBHuAaZ2DjWIvzyFW4LrCtA">https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux/ch05s02.html?fbclid=IwAR2X9zgwtSH6GW2_K67UrxjYDAVgljqV0i5KmBHuAaZ2DjWIvzyFW4LrCtA</link>
        </para>
        <para>
             Elsőnek is definiáljuk az állandókat és a fejléceket. Az állandók közül most is a buffer a beolvasáshoz szükséges, a kulcs mérete megint a kulcsot tartalmazó tömbhöz kell ami az előzőleg használt kód miatt 8. A fő függvény előtt találunk függvényeket. Az átlagos szóhossz és a tiszta lehet függvény a törés gyorsaságát segítik elő. Az átlagos szóhossz megadja az szóhossz atlagat még a tiszta lehet pedig a gyakori magyar szavakat figyeli. A void exor () fügvény megkap egy kulcsot, a méretét, a titkos szövegnek a tömbjét és annak a méretét.Itt a forciklusban a kulcsot össze exortálja a titkos szöveggel. Az exor_tores függvény meghívja az exor függvényt is vissza adja a tiszta szöveget. A fő függvényben láthatjuk deklarációk után a titkos szöveg beolvasását.Utánna a program megnézi az összes lehetséges permutációt és a megoldást kííratja a kimenetre, ezzel a kóddal a 3.2 programot használva fel tudjuk törni a szöveget.
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
          
    </section>               
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            A feladatban egy Neurális hálozatot fogunk írni R nyelvben. A nevét a neuron-ról kapta, az az az idegsejtről. Ezekből épűl fel az idegrendszer. Ez egy ingerlékeny sejt, ami ingerület fel és leadásával továbbít információt, amit fel is dolgoz.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
<programlisting language="c"><![CDATA[       
library(neuralnet)
a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
or.data <- data.frame(a1, a2, OR)
nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)
plot(nn.or)
compute(nn.or, or.data[,1:2])
]]></programlisting>
<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/or.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 
	<para>
		A program elején meghívjuk a neuralnet könyvtárat ami tartalmazza a nekünk szükséges függvényeket. A bemenet az a1 és az a2 lesz. A gép most a logikai vagyot, azaz az OR -t fogja megtanulni. Ha a1 és a2 bemenet 0-t ad. Az OR értéke is 0 lesz, minden más esetben az értéke 1. Ezeket az or.data-ban tárolja el a program. Úgy mond "megtanulja". Az nn.or értékét pedig a neuralnet() függvényel határozzuk meg. A függvény első argumentumában a megtanuladnó érték van, aza hogy az OR értéke 0 legyen vagy 1. A második argumentumban adjuk meg az or.data ami alapján tanulja meg a program. A harmadik argumentumban rejtett neutronok száma van. A stepmax a lépésszámot adja. A plot függvénnyel kirajzolunk (lásd a képen) a tanulás folyamatának egyik esetét.
	</para>
<programlisting language="c"><![CDATA[       
library(neuralnet)
a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)
AND   <- c(0,0,0,1)
orand.data <- data.frame(a1, a2, OR, AND)
nn.orand <- neuralnet(OR+AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)
plot(nn.orand)
compute(nn.orand, orand.data[,1:2])
]]></programlisting>
<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/and.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 
<para>
	A programunk azzal bővül, hogy megtanítjuk a programnak az OR-t és az AND-et fogja megtanulni a program. A különbség az előzőtöl annyi, hogy az AND csak akkor kap 1 értéket, ha a1 és a2 értéke is 1, különben az AND értéke 0. A tanulás folyamat ugyan olyan mint az előző. A tanulás módját az orand.data-ba mentjük.
</para>
<programlisting language="c"><![CDATA[
a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)
exor.data <- data.frame(a1, a2, EXOR)
nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)
plot(nn.exor)
compute(nn.exor, exor.data[,1:2])
]]></programlisting>
<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/exor.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 
<para>
	Itt pedig az EXORT tanítatjuk meg a programmal. Az EXOR-nál az EXOR értéke akkor 1, ha az a1 és a2 értéke 1,0 vagy 0,1 . Ha mind akét érték 0,0 vagy 1,1 akkor az EXOR értéke 0 lesz. Ezt a tanulási mintát az exor.data-ban mentjük el. És a tanulás pont úgyanúgy van mint a fentiekben. A képen láthatjuk, hogy a program nem tanulta meg amit kell, ugyanis az eredmények hibásak. A kulcs abban van, hogy a rejtett neutronok értéke 0. A következőben nézzük meg a megoldását.
</para>        
<programlisting language="c"><![CDATA[
a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)
exor.data <- data.frame(a1, a2, EXOR)
nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)
plot(nn.exor)
compute(nn.exor, exor.data[,1:2])
        	]]></programlisting>
        <para>
           Itt anyiban változtattunk, hogy a rejtett neutronoknak létrehoztunk 3 réteget , a rétegek értékei 6,4,6. Ahogy a képen is látszik, az eremény így helyes. 
        </para> 
        <mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/exorjo.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>            
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            A perceptron a mesterséges inteligenciának olyan, mint az agynak a neuron. A program képes feldolgozni és megtanulni a bemenetet, ami 0,1 ből áll.
        </para>
        <para>
            Forrás:<link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Kód:            
        </para>
        <programlisting language="c"><![CDATA[
        #include <iostream>
#include "mlp.hpp"
#include "png++/png.hpp"
int main (int argc, char **argv) 
{
    png::image <png::rgb_pixel> png_image (argv[1]); 
    int size = png_image.get_width()*png_image.get_height();
    
    Perceptron* p = new Perceptron(3, size, 256, 1);
    double* image = new double[size];
    for(int i {0}; i<png_image.get_width(); ++i)
         for(int j {0}; j<png_image.get_height(); ++j)
            image[i*png_image.get_width()+j] = png_image[i][j].red;
    double value = (*p) (image); 
    std::cout << value << std::endl;
    delete p; 
    delete [] image; 
}
        ]]></programlisting>
        <para>
            A kód magyarázata: két headere van szükségünk az "mlp.hpp" és a "png++/png.hpp" -re, ezek a megjelenítés miatt kellenek nekünk és ebbe van a perceptron elve is. A fő fügvényünk elején lefoglaljuk a tárhelyet a képnek és megadjuk a méreteit. Következik a perceptron létrehozása és a megfelelő értékek hozzá adása. A "double* image = new double[size];" sorral  a végélétrehozunk egy size méretű képet és utánna feltöltjük a megadott képpel. A delete parancsokkal töröljük a perceptront és a képet.
        </para>            
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        <para>
            Mandelbrot halmaz egy halmaz a komplex számsíkon. Nevét Benoit Mandelrol kapta, aki megfogalmazta a fraktálok fogalmát (A fraktálok komplex alakzatok).
        </para>
        <para>
            Forrás:<link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/kezdo/elsocpp/mandelbrot/mandelbrot.cpp">https://sourceforge.net/p/udprog/code/ci/master/tree/source/kezdo/elsocpp/mandelbrot/mandelbrot.cpp</link>
        </para>
        <para>
            Kód:               
        </para>
      <programlisting language="c"><![CDATA[   
#include <stdio.h>
#include <stdlib.h>
#include <png.h>
#include <sys/times.h>
#include <libpng16/png.h>

#define SIZE 600
#define ITERATION_LIMIT 32000

void mandel (int buffer[SIZE][SIZE]) {

    clock_t delta = clock ();
    struct tms tmsbuf1, tmsbuf2;
    times (&tmsbuf1);

    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int width = SIZE, height = SIZE, iterationLimit = ITERATION_LIMIT;

    float dx = (b - a) / width;
    float dy = (d - c) / height;
    float reC, imC, reZ, imZ, newReZ, newImZ;

    int iteration = 0;
    
    for (int j = 0; j < height; ++j)
    {
        for (int k = 0; k < width; ++k)
        {
            
            reC = a + k * dx;
            imC = d - j * dy;
            
            reZ = 0;
            imZ = 0;
            iteration = 0;
            
            while (reZ * reZ + imZ * imZ < 4 && iteration < iterationLimit)
            {
                newReZ = reZ * reZ - imZ * imZ + reC;
                newImZ = 2 * reZ * imZ + imC;
                reZ = newReZ;
                imZ = newImZ;

                ++iteration;

            }

            buffer[j][k] = iteration;
        }
    }

    times (&tmsbuf2);
    printf("%ld\n",tmsbuf2.tms_utime - tmsbuf1.tms_utime
              + tmsbuf2.tms_stime - tmsbuf1.tms_stime);

    delta = clock () - delta;
    printf("%f sec\n",(float) delta / CLOCKS_PER_SEC);

}

int main (int argc, char *argv[])
{

    if (argc != 2)
    {
        printf("Hasznalat: ./mandelpng fajlnev\n");
        return -1;
    }
    FILE *fp = fopen(argv[1], "wb");
        if(!fp) return -1;
    
    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
    
    if(!png_ptr)
        return -1;
    png_infop info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr)
    {
        png_destroy_write_struct(&png_ptr,(png_infopp)NULL);
        return -1;
    }
   if (setjmp(png_jmpbuf(png_ptr)))
    {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        fclose(fp);
        return -1;
    }
    png_init_io(png_ptr, fp);

   
    png_set_IHDR(png_ptr, info_ptr, SIZE, SIZE,
            8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
            PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

  
    
    png_text title_text;
    title_text.compression = PNG_TEXT_COMPRESSION_NONE;
    title_text.key = "Title";
    title_text.text = "Mandelbrot halmaz";
    png_set_text(png_ptr, info_ptr, &title_text, 1);
    

    png_write_info(png_ptr, info_ptr);
   
    png_bytep row = (png_bytep) malloc(3 * SIZE * sizeof(png_byte));
    
    
    int buffer[SIZE][SIZE];

    mandel(buffer);

    for (int j = 0; j < SIZE; ++j)
    {
        for (int k = 0; k < SIZE; ++k)
        {
            row[k*3] = (255 - (255 * buffer[j][k]) / ITERATION_LIMIT);
            row[k*3+1] = (255 - (255 * buffer[j][k]) / ITERATION_LIMIT);
            row[k*3+2] = (255 - (255 * buffer[j][k]) / ITERATION_LIMIT);
            row[k*3+3] = (255 - (255 * buffer[j][k]) / ITERATION_LIMIT);
        }
        png_write_row(png_ptr, row);
    }
    png_write_end(png_ptr, NULL);

    printf("%s mentve\n",argv[1]);

}
      	]]></programlisting>
	<para>
      	A png.h headerre van szükségégünk ahoz hogy png-t tudjunk kezelni. Ez alapból nincs meg a gépen, ezért először is le kell töltenünk az internetről egy fájlt ami tartalmazza a headert. Miután ezt letöltöttük, még telepíteni kell a libpng könyvtárat az alábbi módon:  "sudo apt-get install libpng++-dev".	
      	</para>	      	
	<para>Az include-ról kicsit lejebb, bővebben kifejtve beszélek majd. A kódot állandók definiálásával kezdjük, ilyen lesz a kép maximum szélessége, magassága. Az első függvény fogja nekünk legenerálni a képet. A "png" csomagot használjuk ehez. Létrehozunk egy üres pngt ami 500x500 pixel ((500X500 as mátrix)). A forcikluson belül rgb színkóddal határozzuk meg a színes pixeleket.  és a "image.write" a képet kiküldjük a kimenetrre egy adott névvel. ez a függvény a fő függvény legalján lesz meghívví. A következő egy struktúra amiben 2 double tipusú változót deklarálunk , ez a komplex számoknak a struktúrája. Ezután a fő függvényben létrehozunk egy tömböt ami 500x500 elemű. Ezekhez az állandókat használjuk. 3 egész tipusú deklarálása után 2 double változót deklarálunk a "dx" és "dy" amivel a pixeleket fogunk meghatározni. A következő sorban lefoglaljuk a helyet c, z, zuj változoknak, utánna elvégezzük a számításokat és beletesszük azokat a tömbe és meghívjuk a függvényt amivel legeneráljuk.
      	</para>	
      	<programlisting language="c"><![CDATA[
    for (int j = 0; j < height; ++j)
    {
        for (int k = 0; k < width; ++k)
        {
            
            reC = a + k * dx;
            imC = d - j * dy;
            
            reZ = 0;
            imZ = 0;
            iteration = 0;
            
            while (reZ * reZ + imZ * imZ < 4 && iteration < iterationLimit)
            {
                newReZ = reZ * reZ - imZ * imZ + reC;
                newImZ = 2 * reZ * imZ + imC;
                reZ = newReZ;
                imZ = newImZ;

                ++iteration;

            }

            buffer[j][k] = iteration;
        }
    }
	]]></programlisting>
	<para>A fenti részlet számolja ki a komplex számot. Erre azért van szükség, mert nem használjuk a komplex osztályt. A lenti képen találhatjuk meg a kimeneti fájlt, amit úgy kapunk meg, ha program megírása után így kompiláljuk: gcc -o mandelhalmaz mandelhalmaz.c -lpng.
A futatáshoz pedig ./mandelhalmaz mandelh2.png parancsot használjuk, ahol a második rész a kimeneti fájl neve.
      	</para>	
      	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/mandel.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
	<para>
          Itt a feladat ugyan az mint az előző pontban. A különbség, hogy itt most használjuk a complex headert. Ahogy említve volt az elöző feladatban is, a komplex osztály segítségével egy teljes strúkturát sporolhatunk meg.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <programlisting language="c"><![CDATA[
#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./complex fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  for ( int j = 0; j < magassag; ++j )
    {

      for ( int k = 0; k < szelesseg; ++k )
        {
          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
	]]></programlisting>
	<para>
            A fő függvényben dekralálunk 2 változót, ha argumentumként jól adjuk meg ezeket, akkor ezeket átadja a változóknak, ha nem jól adjuk meg, akkor kiírjuk, hogy kell helyesen használni.
            Ezek után megadjuk a szélességet és a magasságot,ami ebbe az esetbe FullHD és az iterácoós határt. Továbbá létrehozunk változókat, amik a kép elkészítéséhez kellenek majd. Az if fügvény vizsgálja meg, az argumentum érvényességét, illetve itt adja át az előbb említett értékeket. Az else ág a rossz esetén, a segítséget írja ki. Ezek után lefoglaljuk a helyet a képnek. A dx, dy-hez hozzá rendeljük a megfelelő változókat. A forciklusban végig megyünk minden elemen és megadjuk a c változó értékét. Ekkor használjuk a complex-et, while ciklusban végezzük a számításokat, utánna rgb kóddal a pixeleket kiszinezzük.
        </para>
        <para>
            A futtatáshoz szükségünk lesz a -lpng kapcsolóra.                 
        </para>
	<programlisting language="c"><![CDATA[
	if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./complex fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }
	]]></programlisting>
	<para>
            A fenti kód kommentárba helyezésével, elérhetjük, hogy a program ne kommunikáljon a felhasználóval, azaz az értékeket csak a forráskódban lehet változtatni és az előre meghatározott számokkal fog dolgozni. Ezzel egyszerűsíthető a program a kezdő felhasználók számára. A következő két képen láthatjuk majd a program végeredményét az alapértelmezett beépített értékekkel, illetve egy képet, ami felhasználó által megadott értékkel lett elkészítve.                
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/complex2.png" format="PNG" scale="15"/>
        	</imageobject>
        </mediaobject>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/complex.png" format="PNG" scale="15"/>
        	</imageobject>
        </mediaobject>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        	A biomorf program a mandelbrot programkódját vesszi alapul. A mandelbrot halmaz tarttarlmazza az összes ilyen halmazt. A program ugyanúgy bekéri a megfelelő bemeneteket, ha nem jó akkor kiírja. Ha jó, akkor a megfelelő változók megkapják a megfelelő értékeket. Ezután történik a kép létrehozása. Ugyan úgy megkapja a dx és dy az értéket. Aztán pedig a komplex számokat gozzuk létre. Megint végig megy a program minden ponton és ahol kell használjuk az rgb kódos színezést. A legvégén pedig kiküldjük a képet a kimenetre.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            Kód:
        </para> 
        <programlisting language="c"><![CDATA[
 #include <iostream>
#include "png++/png.hpp"
#include <complex>
int
main ( int argc, char *argv[] )
{
    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;
    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );
    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }
    png::image < png::rgb_pixel > kep ( szelesseg, magassag );
    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;
    std::complex<double> cc ( reC, imC );
    std::cout << "Szamitas\n";
    for ( int y = 0; y < magassag; ++y )
    {
       
        for ( int x = 0; x < szelesseg; ++x )
        {
            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );
            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }
        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }
    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;
}
       	
        ]]></programlisting>     
         <mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/bmorf.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>                  
    </section>                                            

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
          Továbbra is a mandelbrot halmazzal foglalkozunk, de mi is az a cuda? A CUDA az Nvidia videókártyáknak egy párhuzamos számításokat segítő technólógia. Használható C és C++ nyelveknél is. Ezen technika segítségével fogjuk felgyórsítani a kép létrehozását. Ehez szükségünk lesz egy Nvidida videókártyára ami rendelkezik CUDA-val. Továbbá telepítenünk kell. A kód kiterjesztése ".cu"
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://progpater.blog.hu/2011/03/27/a_parhuzamossag_gyonyorkodtet">https://progpater.blog.hu/2011/03/27/a_parhuzamossag_gyonyorkodtet</link>
        </para>
        <para>
          Kód:
        </para>
        <programlisting language="c"><![CDATA[
#include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>
#include <sys/times.h>
#include <iostream>
#define MERET 600
#define ITER_HAT 32000
__device__ int
mandel (int k, int j)
{
float a = -2.0, b = .7, c = -1.35, d = 1.35;
int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;
float dx = (b - a) / szelesseg;
float dy = (d - c) / magassag;
float reC, imC, reZ, imZ, ujreZ, ujimZ;
int iteracio = 0;
reC = a + k * dx;
imC = d - j * dy;
reZ = 0.0;
imZ = 0.0;
iteracio = 0;
while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
    // z_{n+1} = z_n * z_n + c
    ujreZ = reZ * reZ - imZ * imZ + reC;
    ujimZ = 2 * reZ * imZ + imC;
    reZ = ujreZ;
    imZ = ujimZ;
    ++iteracio;
    }
return iteracio;
}
/*
__global__ void
mandelkernel (int *kepadat)
{
int j = blockIdx.x;
int k = blockIdx.y;
kepadat[j + k * MERET] = mandel (j, k);
}
*/
__global__ void
mandelkernel (int *kepadat)
{
int tj = threadIdx.x;
int tk = threadIdx.y;
int j = blockIdx.x * 10 + tj;
int k = blockIdx.y * 10 + tk;
kepadat[j + k * MERET] = mandel (j, k);
}
void
cudamandel (int kepadat[MERET][MERET])
{
int *device_kepadat;
cudaMalloc ((void **) &device_kepadat, MERET * MERET * sizeof (int));
dim3 grid (MERET / 10, MERET / 10);
dim3 tgrid (10, 10);
mandelkernel <<< grid, tgrid >>> (device_kepadat);  
cudaMemcpy (kepadat, device_kepadat,
        MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
cudaFree (device_kepadat);
}
int
main (int argc, char *argv[])
{
clock_t delta = clock ();
struct tms tmsbuf1, tmsbuf2;
times (&tmsbuf1);
if (argc != 2)
    {
    std::cout << "Hasznalat: ./mandelpngc fajlnev";
    return -1;
    }
int kepadat[MERET][MERET];
cudamandel (kepadat);
png::image < png::rgb_pixel > kep (MERET, MERET);
for (int j = 0; j < MERET; ++j)
    {
    for (int k = 0; k < MERET; ++k)
    {
    kep.set_pixel (k, j,
            png::rgb_pixel (255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT));
    }
    }
kep.write (argv[1]);
std::cout << argv[1] << " mentve" << std::endl;
times (&tmsbuf2);
std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;
delta = clock () - delta;
std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;
}
]]></programlisting>
        <para>
          Nézzük a kódot. Az fejlécek alatt két állandót definiálunk, a kép méretét és az iterációs határt. A következő lépés a Mandelbrot halmaz létrehozása. Ezt egy függvénnyel hozzuk létre. A függvény előtt jelezzük, hogy a számításokat Cudával végezzük majd a fordításnál. A függvényen belül deklarálunk float tipusú változókat a számításokhoz. A matematikai számítás ugyan az mint az 5.1 feladatban, szóval ezt nem fejtem ki most. A következő függvény előtt nem "__device__" jelzés van hanem "__global__" . Ezzel szintén azt jelezzük, hogy a Cuda fogja végezni a számítást. A "threadIdx" jelzi az aktuális szálat és a "blockIdx", hogy melyik blokban folyik a számítás. A kép értékeit a j és a k változókban tároljuk el. Ezt a két értéket fogja kapni az előző függvény. A következő függvény a cudamandel(). Ez egy Méret x Méret azaz 600x600-as tömböt kap. Deklarálunk egy mutatót és a Malloc segítségével lefoglaljuk a megfelelő tárhelyet és a mutató ide fog mutatni. Itt hozzuk létre a megfelelő blokkokat. A végén a tárhelyet felszabadítjuk. A fő függvényünkben sem történik nagy változás. Egyből egy idő méréssel kezdünk. Lemérjük mennyi időbe telik a gépnek, hogy megalkossa a képet. Utánna deklaráljuk a tömböt, meghívjuk a cudamandel() függvényt és már az ismert módon létrehozzuk a képet.
        </para>
        <para>
          A kódot az "nvcc" fordítóval fordítjuk, le kell tölteni, ehez a gép ad segítséget. A következőképpen fordítjuk: "nvcc mandelpngc_60x60_100.cu -lpng16 -O3 -o mandelpngc
          ". Miután fordítottuk utánna futtatjuk. Ha egymás mellé tesszük a Cudas és a nem kudás képalkotást, láthatjuk, hogy a kép elkészítési ideje a cudásnál sokkal gyorsabb.
        </para>
    </section>                     
             
    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            A program azt fogja csinálni, hogy létrejön nekünk egy mandelbrot halmaz és az egérrel képesek vagyunk belenagyítani akár a végtelenségig a halmazba.
        </para>
            
        <para>
            Kód:  
        </para>
<programlisting language="c"><![CDATA[
#include<QApplication>
#include "frakablak.h"
int main(int argc, char *argv[])
{
	QApplication a(argc, argv);
	Frakablak w1,
	w2(-.08292191725019529, -.082921917244591272,
	   -.9662079988595939, -.9662079988551172, 1200, 3000),
	w3(-.08292191724880625, -.0829219172470933,
	   -.9662079988581493, -.9662079988563615, 1200, 4000),
	w4(.14388310361318304, .14388310362702217,
	   .6523089200729396, .6523089200854384, 1200, 38655);
	w1.show();
	w2.show();
	w3.show();
	w4.show();
	return a.exec();
}
       	]]></programlisting>
        <para>
           Ez a program nem elég önmagában, több forrásra van szükséunk. ilyen például a frakablak.h header. Egy mappába össze kell szednünk az összes forrást és telepítenünk kell ezt: "sudo apt-get install libqt4-dev". A qmake -project parancsal létrehozunk egy .pro fájlt. ebbe meg kell adnunk a QT+=Widgets parancsot a megfelelő helyre. Ez létrehoz egy fájlokat .o kiterjesztéssel és egy makefilet, ezek után make parancsal létrehozzuk a nagyítót. Ezek után kész is a programunk. A frakszal.cpp-ben készül el az ábránk amit majd nagyítani fogunk. Az rgb pixel színezést azonban már a frakablak végzi. 
        </para> 
        <para>
          Forrás:<link xlink:href="https://progpater.blog.hu/2011/03/26/kepes_egypercesek">https://progpater.blog.hu/2011/03/26/kepes_egypercesek</link>
        </para>
<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/nagynagy.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 

<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/nagykicsi.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 

    </section>
                                                                                                                                                               
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
          Ebben a feladatban az 5.5 feladatot fogjuk megírni Java-ban. A program lényege itt is az, hogy a mandelbrothalmazba belenagyítunk. 
        </para>
        <para>
          A program elején létrehozzuk a Mandelbrot halmazt. Ehez az extends szóval hozzá kapcsoljuk a Mandelbrothalmazt építő java kódunkat. A mousePressed() függvényel megadjuk a programnak az egér által kijelőlt kordinátákat. Ezután A kijelőlt területen újraszámoljuk a halmazt. Majd feldolgozza a létre jött kép szélét és magasságát. A pillanatfelvétel() függvénnyel egy pillanatfelvételt készítünk. A függvényen belül elnevezzük a tartomány szerint és egy png formátumú képet készítünk a pillanatfelvételből. A nagyítás során láthatunk egy segítő négyzetet, ezt a paint() függvényel hozzuk létre. 
        </para>
        <para>
          A kód forrása:<link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html</link> 
        </para>
<programlisting language="c"><![CDATA[        
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    private int x, y;
    private int mx, my;
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }
            public void mouseReleased(java.awt.event.MouseEvent m) {
                double dx = (MandelbrotHalmazNagyító.this.b
                        - MandelbrotHalmazNagyító.this.a)
                        /MandelbrotHalmazNagyító.this.szélesség;
                double dy = (MandelbrotHalmazNagyító.this.d
                        - MandelbrotHalmazNagyító.this.c)
                        /MandelbrotHalmazNagyító.this.magasság;
                new MandelbrotHalmazNagyító(MandelbrotHalmazNagyító.this.a+x*dx,
                        MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                        MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                        MandelbrotHalmazNagyító.this.d-y*dy,
                        600,
                        MandelbrotHalmazNagyító.this.iterációsHatár);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }
    public void pillanatfelvétel() {
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();        
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }    
    public void paint(java.awt.Graphics g) {
         g.drawImage(kép, 0, 0, this);        
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }
    public static void main(String[] args) {
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}
]]></programlisting>
        <mediaobject>
          <imageobject condition="printf">
            <imagedata fileref="img/javanagy.png" format="PNG" scale="30"/>
          </imageobject>
        </mediaobject> 
        <mediaobject>
          <imageobject condition="printf">
            <imagedata fileref="img/javakicsi.png" format="PNG" scale="30"/>
          </imageobject>
        </mediaobject>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <programlisting language="c"><![CDATA[ 
#include <iostream>
#include <math.h>
#include <pthread.h>
#include <ctime>


class PolarGen
{
public:
  PolarGen()
  {
    nincsTarolt = true;
    std::srand (std::time(NULL));
  }
  ~PolarGen()
  {
  }
  double kovetkezo();
private:
  bool nincsTarolt;
  double tarolt;
};
double PolarGen::kovetkezo ()
{
  if (nincsTarolt)
  {
    double u1, u2, v1, v2, w;
        do
      {
        u1= std::rand() / (RAND_MAX +1.0);
        u2= std::rand() / (RAND_MAX +1.0);
        v1=2*u1-1;
        v2=2*u1-1;
        w=v1*v1+v2*v2;
           }
    while (w>1);
    double r =std::sqrt ((-2 * std::log(w)) /w);
    tarolt=r*v2;
    nincsTarolt =!nincsTarolt;
    return r* v1;
   }
   else
   {
    nincsTarolt =!nincsTarolt;
    return tarolt;
   }
}
int main (int argc, char **argv)
{
    PolarGen pg;
    for (int i= 0; i<10;i++)
      std::cout<<pg.kovetkezo ()<< std::endl;
    return 0;
}
]]></programlisting>        
        <para>
            Ez a program véletlenszerűen fog számokat generálni nekünk. Azért csak véletlenszerűen, mert a véletlent nem lehet generálni, már ha egyáltalán úgy gondoljuk, hogy létezik véletlen. Ezt egy osztályon belül fogjuk kivitelezni. Az osztály neve a PolarGen-t kapta. Két részre tudjuk bontani. Van egy nyilvános és egy privát. A nyilvános részhez hozzá tudunk férni, viszont a privát részt, csak az osztályon belül tudjuk meghívni. Az osztály elején egyből ott van a koonstruktor ezt onnan tudjuk felismerni, hogy ugyan úgy hívjuk ahogyan az osztályt is. Ebben kezdő értékeket tudunk adni és egy objektum létrehozásával egyből lefut. Esetünkben most a "nincsTarolt" privát változó értékét fogja "True"-ra állítani és az srand is itt lesz, ami a véletlenszerű szám generálásához kell. Utánna van a destruktor ami ugyan úgy néz ki mint a konstruktor csak előtte van '~' jel. Ez a program végén fog lefutni. Ebben felszabadítjuk a memóriát. A privát részben létrehozunk egy logikai és egy double tipusú változót. A kovetkezo() függvény az, amiben a random számokat fogjuk létrehozni. Azt, hogy ezt hogyan végezzük matematikailag, most figyelmenkívül hagyjuk. A main függvényben meghívunk egy osztálytípusú változót. Ez fogja beindítani a konstruktort. Utánna pedig egy forciklusban tíz véletlen száot íratunk ki.            
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/polc.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
	<para>
            Látható, hogy a meghívás során különböző értékeket kapunk vissza, amelyeket a program kétszer ír ki.
        </para>
        <para>
            Java:
        </para>
         <programlisting language="java"><![CDATA[
public class PolarGenerator
{
    boolean nincsTarolt = true;
    double tarolt;
    
    public PolarGenerator()
    {
        nincsTarolt = true;
    }
    
    public double kovetkezo() 
    {
        if(nincsTarolt)
        {
            double u1, u2, v1, v2, w;
            do{
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2* u1 -1;
                v2 = 2* u2 -1;
                w = v1*v1 + v2*v2;
            } while (w>1);
            
            double r = Math.sqrt((-2 * Math.log(w) / w));
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;
            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }
    
    public static void main(String[] args)
    {
        PolarGenerator g = new PolarGenerator();
        for (int i = 0; i < 10; ++i)
        {
            System.out.println(g.kovetkezo());
        }
    }
}]]>
            </programlisting>
            <para>
                Ez az előző program csak javaban megírva. A program felépítése sokkal átláthatóbb és egyszerűbb lett. Alapjaiban ugyan úgy működik mint a C++ megfelelője.
            </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/poljava.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 
        <para>
                A képen látható, hogy a Java változatt is különböző értékeket add a két meghívás során.
            </para>   
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            A program a bemeneti adatokból egy bináris fát épít. Bármely típusú fa ábrázolható bináris fa segítségével. A bináris fa legfőbb jellemzője az, hogy bármelyik csomópontnak csak legfeljebb két utóda lehet. A bináris fák utódjait megkülönböztetjük aszerint, hogy bal illetve jobb részfák. A fa 0 és 1 számokból épül fel. A kitüntetett elem a gyökér. Innen minden elemet el tudunk érni. A következőben megnézzük, hogy is működik ez. Az eltérés, hog itt nem fő függvény van, hanem minden egy osztály része.
        </para>
         <para>
            A kód forrása:<link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat?fbclid=IwAR0R_H4ol5laHPvyjt-p5MQomtcQIdfTeZvPInhgRxu-CCsxGOx453MSrGk">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat?fbclid=IwAR0R_H4ol5laHPvyjt-p5MQomtcQIdfTeZvPInhgRxu-CCsxGOx453MSrGk</link> 
        </para>
         <programlisting language="c"><![CDATA[   
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
typedef struct binfa
{
  int ertek;
  struct binfa *bal_nulla;
  struct binfa *jobb_egy;
} BINFA, *BINFA_PTR;
BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;
  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}
extern void kiir (BINFA_PTR elem);
extern void ratlag (BINFA_PTR elem);
extern void rszoras (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);
int
main (int argc, char **argv)
{
  char b;
  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  gyoker->bal_nulla = gyoker->jobb_egy = NULL;
  BINFA_PTR fa = gyoker;
  while (read (0, (void *) &b, 1))
    {
      if (b == '0')
    {
      if (fa->bal_nulla == NULL)
        {
          fa->bal_nulla = uj_elem ();
          fa->bal_nulla->ertek = 0;
          fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
          fa = gyoker;
        }
      else
        {
          fa = fa->bal_nulla;
        }
    }
      else
    {
      if (fa->jobb_egy == NULL)
        {
          fa->jobb_egy = uj_elem ();
          fa->jobb_egy->ertek = 1;
          fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
          fa = gyoker;
        }
      else
        {
          fa = fa->jobb_egy;
        }
    }
    }
  printf ("\n");
  kiir (gyoker);
  
  extern int max_melyseg, atlagosszeg, melyseg, atlagdb;
  extern double szorasosszeg, atlag;
  printf ("melyseg=%d\n", max_melyseg-1);
  
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  ratlag (gyoker);
  atlag = ((double)atlagosszeg) / atlagdb;
  atlagosszeg = 0;
  melyseg = 0;
  atlagdb = 0;
  szorasosszeg = 0.0;
 rszoras (gyoker);
  double szoras = 0.0;
  if (atlagdb - 1 > 0)
    szoras = sqrt( szorasosszeg / (atlagdb - 1));
  else
    szoras = sqrt (szorasosszeg);
  printf ("altag=%f\nszoras=%f\n", atlag, szoras);*/
  szabadit (gyoker);
}
 
int atlagosszeg = 0, melyseg = 0, atlagdb = 0;
void
ratlag (BINFA_PTR fa)
{
  if (fa != NULL)
    {
      ++melyseg;
      ratlag (fa->jobb_egy);
      ratlag (fa->bal_nulla);
      --melyseg;
      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
    {
      ++atlagdb;
      atlagosszeg += melyseg;
    }
    }
}
double szorasosszeg = 0.0, atlag = 0.0;
void
rszoras (BINFA_PTR fa)
{
  if (fa != NULL)
    {
      ++melyseg;
      rszoras (fa->jobb_egy);
      rszoras (fa->bal_nulla);
      --melyseg;
      if (fa->jobb_egy == NULL && fa->bal_nulla == NULL)
    {
      ++atlagdb;
      szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
    }
    }
}
int max_melyseg = 0;
void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      if (melyseg > max_melyseg)
    max_melyseg = melyseg;
      kiir (elem->jobb_egy);
      for (int i = 0; i < melyseg; ++i)
    printf ("---");
      printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
          melyseg-1);
      kiir (elem->bal_nulla);
      --melyseg;
    }
}
void
szabadit (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      szabadit (elem->jobb_egy);
      szabadit (elem->bal_nulla);
      free (elem);
    }
}
        ]]></programlisting>
        <para>
            Magyarázat: Elsőnek is a szükséges headereket deklaráljuk. Ezek után pedig a Binfánk struktúráját. A struktúra egy egészet tartalmaz aminek a neve "ertek" és 2 mutatóval fog rendelkezni, amiben bal és jobb gyermekeket tároljuk majd.Az 1 érték jobbra fog kerülni, a 0 balra. A "typdef"-vel adunk neki egy nevet, amivel a programon belül fogjuk hívni. Ezután az uj_elem függvény következik. Ez fogja nekünk lefoglalni a tárhelyet a memóriában, ami "NULL" kezdőértékkel fog rendelkezni. Ha nincs memória, akkor hibát dob ki. A végén vissza adja a lefoglalt mutatót. Utánna függvény prototipusokat kapunk, ezek közül a feladatnak megfelelően csak a kiir() és a szabadit() függvényeket fogjuk megvizsgálni. Ugorjunk a main fő függvényre. Az első egy char tipusú változó, ebben fogjuk tárolni ideiglenesen a beolvasott karaktert. Aztán létrehozzuk a gyökérelemet és értékül adunk neki egy karaktert, jelen esetben '/'. A while ciklusban fog zajlani a faépítés. Először is megvizsgálja a beolvasott karaktert. Mindig a gyökér elemtől indul. Ha a beolvasott karakter értéke 0, akkor először megvizsgálja, hogy a gyökérnek vagy az adott csomópontnak van e bal_nullas gyermeke, ha van, akkor rálép a csomópontra, ha viszont nincs, akkor a gyökérnek vagy az adott csomópontnak létrehoz egy bal_nullas gyermeket. Ha a beolvasott karakter értéke 1, akkor a program ugyan ezen az elven mint a 0-ás értéknél végig vizsgálja, csak a jobb_egyes gyermekkel. Most következik a kiír és a szabadit függvény. A szabadit() függvény egy rekurzív függvény. Törli a memóriából az eltárolt elemeket. A kiir() függvény is rekúrzív függvény. Bejárja a fa elemeit.
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/binfa.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject> 
	<para>
            A képen látható  a futatás után létrehozott binfa kirajzolása és egyébb adatok.
        </para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
         <para>
            A fabejáránsak 3 tipusa van, preorder, inorder és postorder. 
         </para>   
        <para>
            Kezdjük a preorder fabejárással. Itt mindig a gyökérrel kezdi a program a vizsgálatot, aztán a bal oldalt legvégezetül, pedig a jobb oldalt fogja bejárni.
        </para>
         <programlisting language="c"><![CDATA[
//preorder fabejárás:
void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
	printf ("%c", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek);      
	kiir (elem->bal_nulla);	
	kiir (elem->jobb_egy);      
    }
}
        ]]></programlisting>
        <para>
            Inorder fabejárás: Az inorder fabejárásnál először a bal oldalt vizsgáljuk meg, utánna jön a gyökér és legvégül pedig a jobb oldalt nézzük.           
        </para>
	<programlisting language="c"><![CDATA[
//inorder fabejárás:
void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
	kiir (elem->bal_nulla);
	printf ("%c", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek);      	
	kiir (elem->jobb_egy);      
    }
}
        ]]></programlisting>
        <para>
            A postorder fabejárás: Itt először a fa bal oldalát fogja átvizsgálni, aztán a jobb oldalt, legutoljára pedig a gyökeret vizsgáljuk.
        </para>
         <programlisting language="c"><![CDATA[
//postorder fabejárás:            
void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
	kiir (elem->bal_nulla);     	
	kiir (elem->jobb_egy);
	printf ("%c", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek);       
    }
}
        ]]></programlisting>
	<para>
            Ahogy a kodolásban látszik a három bejárás megvalosítása szinte semmiben sem különbözik. A változás csupán annyi, hogy az elemet kiíró sor hanyadik utasítás az alprogramban. A lenti képen látható lesz, hogy az egyes bejárások során hova kerül a gyökér elem, ami a / karakter lesz.
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/bejar.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://progpater.blog.hu/2011/03/31/imadni_fogjatok_a_c_t_egy_emberkent_tiszta_szivbol">https://progpater.blog.hu/2011/03/31/imadni_fogjatok_a_c_t_egy_emberkent_tiszta_szivbol</link>                
        </para>
        <para>
            Az alábbi program a fenti C változatnak lesz úgymond a C++ változata. Az első lépés, hogy ami C-ben struktúra volt, azt átírjuk C++-ban egy osztályba, mivel a C++-ban megtehetjük. Ez az alábbi módon fog kinézni:
        </para>
 <programlisting language="c"><![CDATA[
        class LZWBinFa
        {
        public:
        LZWBinFa (char b = '/'):betu (b), balNulla (NULL), jobbEgy (NULL) {};
        ~LZWBinFa () {};
            void operator<<(char b)
    {
        if (b == '0')
        {
            // van '0'-s gyermeke az aktuális csomópontnak?
            if (!fa->nullasGyermek ()) // ha nincs, csinálunk
            {
                Csomopont *uj = new Csomopont ('0');
                fa->ujNullasGyermek (uj);
                fa = &gyoker;
            }
            else // ha van, arra lépünk
            {
                fa = fa->nullasGyermek ();
            }
        }
        else
        {
            if (!fa->egyesGyermek ())
            {
                Csomopont *uj = new Csomopont ('1');
                fa->ujEgyesGyermek (uj);
                fa = &gyoker;
            }
            else
            {
                fa = fa->egyesGyermek ();
            }
        }
    }
        
        ]]></programlisting>
        <para>
           Ezen belül fogjuk a gyökeret létrehozni és értékül adni neki a '/'-t. A mutatóinak értékét 0-ra állítjuk. Ezek után jön a faépítés a már fentiekben elmagyarázott módon. A program megnézi, hogy 1-est vagy 0 érkezik a bemenetről. Itt azt látjuk, hogy a betétel a <function><![CDATA[<<]]></function>  operátorral történik, ez annyiban különbözik a C-ben írt programtól, hogy ez egyből beleteszi a fába a beérkezett karaktert. Egy új csomópontot a "new" szóval tudunk létrehozni, ha szükséges. Ez azért lehetséges mert van egy Csomópont osztályunk (Lásd a lenti programban). A Class csomóponton belül az egyesGyermek() és a nullasGyermek() függvények a gyermekükre mutató pointereket fogják tartalmazni. Az ujNullasGyermek és au ujEgyesGyermek-nek pedig adunk egy gyermeket ás arra fogja állítani a mutatót. A private részben fogjuk ezeket deklarálni, ez azt jelenti, hogy csak az osztályon belül használhatóak ezek a változók. A legvégén jön a main főfüggvény. Itt deklaráljuk a char tipusú változót amibe beolvasunk és innen kerül az osztályokhoz. Végül meghívjuk a kiir és a szabadit függvényeket amire példát az előző programokban találunk. Ugye a kiir()-al kiíratjuk az eredmény és a szabadit()-al pedig felszabadítjuk a lefoglalt meróriát.
         </para>
         <programlisting language="c"><![CDATA[
class Csomopont
    {
    public:
        Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0) {};
        ~Csomopont () {};
        Csomopont *nullasGyermek () {
            return balNulla;
        }
        Csomopont *egyesGyermek ()
        {
            return jobbEgy;
        }
        void ujNullasGyermek (Csomopont * gy)
        {
            balNulla = gy;
        }
        void ujEgyesGyermek (Csomopont * gy)
        {
            jobbEgy = gy;
        }
    private:
        friend class LZWBinFa;
        char betu;
        Csomopont *balNulla;
        Csomopont *jobbEgy;
        Csomopont (const Csomopont &);
        Csomopont & operator=(const Csomopont &);
    }; 
    
  int main ()
  {
        char b;
        LZWBinFa binFa;
        while (std::cin >> b)
        {
        binFa << b;
        }
    binFa.kiir ();
    binFa.szabadit ();
    return 0;
    }    
        ]]></programlisting>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a fával!
        </para>
        <para>
            Vegyük alapul a C++ ban megírt LZWBinfa-t. Első dolgunk, hogy a fában a gyökér elemet átalakítjuk egy mutatóvá. Azt az alábbi módon fogjuk megcsinálni: A gyökér elem a protected részén van az osztálynak. Itt az eredeti "Csomopont gyoker;" az alábbi módon átírunk:
        </para>
        <programlisting language="c">
          <![CDATA[
protected:          
Csomopont *gyoker; 
int maxMelyseg;
double atlag, szoras;
          ]]>
</programlisting>
        <para>
            Ugye C++ ban a mutatót egy '*'-al jelüljuk. Ha most futtatnánk a programot, akkor számtalan hibába ütköznénk. Ezeket ki kell javítanunk. A programban így nem a gyökér memóriacímét kell átadnunk (Töröljük az összes referenciajelet a gyokerek előtt) és mivel mutató lett a gyökér így nem '.'-al hiavatkozunk hanem '-&gt;'-al. Itt láthatunk példát arra, hogy hogyan:
        </para>
<programlisting language="c"><![CDATA[
//előtte:
fa=&gyoker;
//utánna:
fa=gyoker;
 
//előtte:
szabadit (gyoker.egyesGyermek ());
szabadit (gyoker.nullasGyermek ());
//utánna:
szabadit (gyoker->egyesGyermek ());
szabadit (gyoker->nullasGyermek ());
    }]]>
</programlisting>
    <para>
        Ha mindezek után lefuttatjuk a programunkat az lefordul, azonban futtatáskor szegmentális hibába ütközünk. Ez azért van, ugyanis a gyökér memóriacíme nincs lefoglalva. Ennek a megoldását a konstruktorban és a destruktorban fogjuk megalkotni. A konstruktorban foglaljuk le és a destruktorba fogjuk törölni a lefoglalt memóriát. Lásd:
    </para>
  <programlisting language="c"><![CDATA[
LZWBinFa ()
    {
    gyoker= new Csomopont('/');
    fa = gyoker;
    }
~LZWBinFa ()
    {
    szabadit (gyoker->egyesGyermek ());
    szabadit (gyoker->nullasGyermek ());
    delete(gyoker);
    }]]>
</programlisting>
    </section>                            

    <section>
        <title>Mozgató szemantika</title>
        <para>
         Megoldás forrása: <link xlink:href="httsp://sourceforge.net/p/udprog/code/ci/master/tree/source/vedes/elso/z3a7.cpp">httsp://sourceforge.net/p/udprog/code/ci/master/tree/source/vedes/elso/z3a7.cpp</link>    
	</para>   
	<para>
	Védési videó: <link xlink:href="https://www.youtube.com/watch?v=S8bM0rewaTE">https://www.youtube.com/watch?v=S8bM0rewaTE</link>
        </para>
        <programlisting language="c++"><![CDATA[
   		 LZWBinFa ( const LZWBinFa & regi ) {

          gyoker.ujEgyesGyermek ( masol ( regi.gyoker.egyesGyermek (), regi.fa ) );
          gyoker.ujNullasGyermek ( masol ( regi.gyoker.nullasGyermek (), regi.fa ) );

          if ( regi.fa == & ( regi.gyoker ) )
               fa = &gyoker;

     }

     LZWBinFa ( LZWBinFa && regi ) {

          gyoker.ujEgyesGyermek ( regi.gyoker.egyesGyermek() );
          gyoker.ujNullasGyermek ( regi.gyoker.nullasGyermek() );

          regi.gyoker.ujEgyesGyermek ( nullptr );
          regi.gyoker.ujNullasGyermek ( nullptr );

     }

        	]]></programlisting>
        	  <programlisting language="c++"><![CDATA[
       Csomopont *  masol ( Csomopont * elem, Csomopont * regifa ) {

          Csomopont * ujelem = NULL;

          if ( elem != NULL ) {
               ujelem = new Csomopont ( elem->getBetu() );

               ujelem->ujEgyesGyermek ( masol ( elem->egyesGyermek (), regifa ) );
               ujelem->ujNullasGyermek ( masol ( elem->nullasGyermek (), regifa ) );

               if ( regifa == elem )
                    fa = ujelem;

          }

          return ujelem;
     }
]]></programlisting>
<para>
		A forráskódban a binfa működése gyakorlatilag nem változik semmit, ezért arról nem is írnék részletesebben. A mozgató szemantika titka viszont annyiban merül ki, hogy a először is szükségünk van egy másoló konstruktorra, ami egy olyan függvény lesz, ami megkapja a binfa elemeit és ezeket új memóriacímen új jobb és bal elemekként lementi. Ezzel építünk gyakorlatilag egy új fát, aminek minden eleme megegyezik az eredeti fánknak az elemeivel. Amikor ez megtörténik, régi fánknak a gyökerének a pointereit átállítjuk null pointerekre, ezzel pedig töröltük azoknak az elemeit és már csak az új fánk létezik.
	</para>
	<para>
		A fánk mozgatását a main-ben a std::move függvénnyel fogjuk elérni, ami magától nem fogja mozgatni a binfánkat, csakis akkor, ha ehhez meg van írva már a mozgató konstruktorunk.
	</para>

    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
        	Ebben a feladatban egy QT programban fogjuk szimulálni a hangyák mozgását. A való életben a hangyák sose zavarodnak össze, sose torlódnak fel, sőt minél többen vannak annál jobban és gyorsabban mozognak. Továbbá tudjuk , hogy a látásuk nem a legjobb. Tehát a kulcs az egymás közötti komunikáció, ezt feromonokkal érik el. Ebben a szimulációban mi is úgymond feromonokkal fogjuk a hangyák közötti kommunikációt elérni. A szabály, hogy mindig a legerősebb feromonú hanyga felé lépünk, a programban látszik, hogy a hanygák feromon csíkot hagynak maguk után, ami idő elteltével egyre gyengül míg el nem tűnik.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <programlisting language="c"><![CDATA[   
#include <QApplication>
#include <QDesktopWidget>
#include <QDebug>
#include <QDateTime>
#include <QCommandLineOption>
#include <QCommandLineParser>
#include "antwin.h"
int main ( int argc, char *argv[] )
{
    QApplication a ( argc, argv );
    QCommandLineOption szeles_opt ( {"w","szelesseg"}, "Oszlopok (cellakban) szama.", "szelesseg", "200" );
    QCommandLineOption magas_opt ( {"m","magassag"}, "Sorok (cellakban) szama.", "magassag", "150" );
    QCommandLineOption hangyaszam_opt ( {"n","hangyaszam"}, "Hangyak szama.", "hangyaszam", "100" );
    QCommandLineOption sebesseg_opt ( {"t","sebesseg"}, "2 lepes kozotti ido (millisec-ben).", "sebesseg", "100" );
    QCommandLineOption parolgas_opt ( {"p","parolgas"}, "A parolgas erteke.", "parolgas", "8" );
    QCommandLineOption feromon_opt ( {"f","feromon"}, "A hagyott nyom erteke.", "feromon", "11" );
    QCommandLineOption szomszed_opt ( {"s","szomszed"}, "A hagyott nyom erteke a szomszedokban.", "szomszed", "3" );
    QCommandLineOption alapertek_opt ( {"d","alapertek"}, "Indulo ertek a cellakban.", "alapertek", "1" );
    QCommandLineOption maxcella_opt ( {"a","maxcella"}, "Cella max erteke.", "maxcella", "50" );
    QCommandLineOption mincella_opt ( {"i","mincella"}, "Cella min erteke.", "mincella", "2" );
    QCommandLineOption cellamerete_opt ( {"c","cellameret"}, "Hany hangya fer egy cellaba.", "cellameret", "4" );
    QCommandLineParser parser;
    parser.addHelpOption();
    parser.addVersionOption();
    parser.addOption ( szeles_opt );
    parser.addOption ( magas_opt );
    parser.addOption ( hangyaszam_opt );
    parser.addOption ( sebesseg_opt );
    parser.addOption ( parolgas_opt );
    parser.addOption ( feromon_opt );
    parser.addOption ( szomszed_opt );
    parser.addOption ( alapertek_opt );
    parser.addOption ( maxcella_opt );
    parser.addOption ( mincella_opt );
    parser.addOption ( cellamerete_opt );
    parser.process ( a );
    QString szeles = parser.value ( szeles_opt );
    QString magas = parser.value ( magas_opt );
    QString n = parser.value ( hangyaszam_opt );
    QString t = parser.value ( sebesseg_opt );
    QString parolgas = parser.value ( parolgas_opt );
    QString feromon = parser.value ( feromon_opt );
    QString szomszed = parser.value ( szomszed_opt );
    QString alapertek = parser.value ( alapertek_opt );
    QString maxcella = parser.value ( maxcella_opt );
    QString mincella = parser.value ( mincella_opt );
    QString cellameret = parser.value ( cellamerete_opt );
    qsrand ( QDateTime::currentMSecsSinceEpoch() );
    AntWin w ( szeles.toInt(), magas.toInt(), t.toInt(), n.toInt(), feromon.toInt(), szomszed.toInt(), parolgas.toInt(),
                  alapertek.toInt(), mincella.toInt(), maxcella.toInt(),
                  cellameret.toInt() );
    w.show();
    return a.exec();
}
}
      	]]></programlisting>
      	<para>
      		Kezdjük az ant.h tartalmazza a hangya tulajdonságait. Hol van az x és y tengelyen és hogy merre mutat az iránya, merre megy. Az antwin-ban pedig a hangyaboly(ants) van. Továbbá ezen belül adjuk meg, hogy egy cella hány pixelből álljon és hogy az ablak szélessége és magassága mekora. Forciklus-okkal felépítjük cellákból az ablakot és elhelyezzük benne a hangyákat(azt ant-ből). Új és új hangyák jelennek meg. Ezek megváltoztatják a régebbi hanygák irányát. Az antwin.h tartalmazza a billentyűzet parancsait, például a p vel megállítjuk a folyamatot. Az anttheard.cpp tartalmazza a mozgáshoz, törléshez, az új irány megadásához, a hangyák számának eltárolásához szükséges függvényeket. Itt vizsgálja azt is hogy a hanygák száma nő e vagy csökken az idő mulásával.
      	</para> 
      	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/hangya.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>            
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
        	Az életjátékot azaz sejtautómatákat először Naumen János vetette fel. A felvetés a gép önreprodukciójának matematikai modellalkotást tartalmazta. A legismertebb modell a John Horton Conway-féle életjáték. Maga a "játék" egy négyzetrácsos mezön zajlik amin mozognak a sejtek. A sejtek "élete" szabályokhoz van kötve. Megvan adva egy sejt létrejötének, életbenmadardásának vagy elpusztulásának szabálya. Conway erre 3 feltételt szabott meg:
        </para>
        <para>
        	1. szabály: Egy sejt csak úgy éli túl, ha kettő vagy három szomszédja van.
        </para>
        <para>
        	2. szabály: Egy sejt akkor pusztul el, ha kettőnél kevesebb szomszédja van. Ezt elszgetelődésnek hívjuk.A másik eset hogy akkor pusztul el ha háromnál több szomszédja van. Ezt túlnépesedésnek hívjuk.
        </para>
         <para>
        	3. szabály: A harmadik szabály a születésre vonatkozik, és akkor történik meg ha egy cellának a körzetében 3 sejt található.
        </para>
        <para>
        	Ezen 3 szabály meghatározásával kapunk egy önműködő sejtautómatát. Beleszolásunk csak kezdetben van, utánna a szabyályok szerint önállóan működik a program. Mi most külön a sikló-kilövőt fogjuk vizsgálni. Hogy ezt elérjük, rőgzítenünk kell adott cellákban sejteket, így létre jőn egy "sikló ágyú", ez időközönként "siklókat" fog lőni.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html?fbclid=IwAR0Gc-Q7v353l_qDrqAd4LfIhWrzTwYnnsTZ5wTpBAhQjwZ63pl2moebOpY">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html?fbclid=IwAR0Gc-Q7v353l_qDrqAd4LfIhWrzTwYnnsTZ5wTpBAhQjwZ63pl2moebOpY</link>               
        </para>
        <para>
        	Kód:
        </para>
        <programlisting language="java"><![CDATA[   
public class Sejtautomata extends java.awt.Frame implements Runnable {
    public static final boolean ÉLŐ = true;
    public static final boolean HALOTT = false;
    protected boolean [][][] rácsok = new boolean [2][][];
    protected boolean [][] rács;
    protected int rácsIndex = 0;
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;/
    protected int szélesség = 20;
    protected int magasság = 10;  
    protected int várakozás = 1000;
    private java.awt.Robot robot;
    private boolean pillanatfelvétel = false;
    private static int pillanatfelvételSzámláló = 0;
    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        siklóKilövő(rács, 5, 60);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });
        cellaSzélesség = 10;
        cellaMagasság = 10;
        try {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        } catch(java.awt.AWTException e) {
            e.printStackTrace();
        }
        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szélesség*cellaSzélesség,
                magasság*cellaMagasság);
        setVisible(true);
        new Thread(this).start();
    }
    public void paint(java.awt.Graphics g) {
        boolean [][] rács = rácsok[rácsIndex];
        for(int i=0; i<rács.length; ++i) { // végig lépked a sorokon
            for(int j=0; j<rács[0].length; ++j) { // s az oszlopok
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }
        if(pillanatfelvétel) {
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                if(!((i==0) && (j==0))) {
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }
    public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }
    public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }
    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        // A pillanatfelvétel kép fájlneve
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }  
    public void update(java.awt.Graphics g) {
        paint(g);
    }
    public static void main(String[] args) {
        new Sejtautomata(100, 75);
    }
}                
      	]]></programlisting>
        <para>
          A program elején megadjuk, hogy egy sejt lehet élő vagy halott. A feladatban 2 rácsfélét használunk, az egyik rács a sejt állapotát fogja tárolni míg a második az egy másdopercel későbbi tulajdonságait. Meghatározzuk az aktuális rácsot a rácsIndex-el. Utánna egy cella magasságát és szélességét, ezt követően pedig, hogy hány cellából álljon a "játék". A következő hogy a az állapotok között mennyi idő teljen el. A függvények közül az első megkapja a méreteket és létrehozza az ablakot. Itt készíti el a 2 rácsot és az indexet is elindítja. Kezdetben minden rács HALOTT. Ezen belül lesz meghívva a siklólövő aminek a kód végén minden kordinátája megvan adva.  Vannak billentyűről beérkezőparancsaink is, különböző feladatokkal ellátva pl a "g" betűvel, a két állapot közötti időt csökkentjük. Ugyan így vannak az egérrel történő infromációk feldolgozására szolgáló függvények. Külön a kattintásra és a mozgatásra. Külön tudunk készíteni pillanatfelvételt az aktuális állapotról az "s" gomb segítségével. A programban a sejtér rajzolását a paint() függvénnyel végezzük. A szomszédokSzáma() függvéynben vizsgáljuk a szabályokat és aszerint történik a sejtek viselkedése.
        </para>
         <mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/eletjatekjava.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most alkossuk meg az életjátékot Qt C++-ban is. A program lényege itt is ugyan az, mint a java-ban. A szabályok ugyan azok. Ha kettő vagy három szomszédja van, akkor életben marad, ha 2-nél kevesebb kipusztul, ha 3 nál több, akkor tulnépesedés miatt elpusztul. Itt is a siklóágyú lesz a fő célunk.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/labor/Qt/Sejtauto/">https://sourceforge.net/p/udprog/code/ci/master/tree/source/labor/Qt/Sejtauto/</link>               
        </para>
         <programlisting language="c"><![CDATA[   
#include <QApplication>
#include "sejtablak.h"
#include <QDesktopWidget>
int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  SejtAblak w(100, 75);
  w.show();
  
  return a.exec();
}
      	]]></programlisting>
        <para>
          A forrásfájljaink a Sejtablak.cpp , sejtszal.h, sejtszal.cpp és a sejtablak.h . Ezek az átláthatóság miatt vannak külön. A sejtablak.h és .cpp tartalmazza a függvényeket amivel majd a kirajzolás fog történni és ebben van a sikló lövés is,úgy mint a java-s párjánál, külön minden egyes cellát megadunk amiben sejt van. A szejtszal.h és .c pedig az életjátékhoz szükséges szabályokat . Ezen belül vannak a függvények melyek az adott állapotokat vizsgálják és a szabáylok szerint alakítják a programot.         
        </para>    
        <mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/eletjatekqt.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        	Elsőnek is a Benchmark jelentését nézzük meg. A benchmark egy elemzés, tesztfeladat. Egy bizonyos tesztet végez el és azt az elért pontszám alapján összehasonlítja a tesztet elvégzők között. Ilyen például  telefonok teljesítményét végző benchmark , vagy az esetünkben az agy teljesítményét vizsgáló. Ennek segítségével tudunk egy vizsonyítási alapot venni egy adott feladatban. Például a telefonoknál, hogy minél több pontot ér el annál jobb a teljesítménye és össze tudjuk hasonlítani más telefonokkal. Ugyan így a BraniBenchmarkban, a tesztet megoldó emberek közül az adott pontszám megadja, hogy ki teljesített a legjobban és egymáshoz is tudjuk vizsonyítani őket.
        	Az adott programunk az egyének figyelemképpeségét és koncentrációját fogja vizsgálni. Adott egy karakter, ami a mi karakterünk és azon kell tartanunk az egér kurzort. A program azt vizsgálja, hogy mennyi ideig vagyunk képesek a kurzort a mi karakterünkön tartani, azaz meddig nem veszítjük el azt. Persze nem ilyen egyszerű, mert közben rengeteg új karakter jelenik meg a monitoron befolyásolva ezzel minket, hogy elveszítsük a karakterünket. A program arra is reagál, ha elveszítjük a karakterünk. 
        </para>
        <para>
        	Az adott programban a mi karakterünk Samu lesz. Samut figyelemmel kell tartani. Ahogy fent említettem ezt a kurzorral fogjuk megtenni. Minél tovább tartjuk Samun a kurzort annál több másik karakter lesz a képernyőn. A feladat 10 percig tart és annál jobb vagy ha minél több kis karakter között is megtudod tartani a saját karaktered.  Ha elveszítenéd abban az esetben belassul az új karakterek megjelenése míg meg nem találod. Annál jobban teljesítettél, minél több pontod van a 10 perc végén.
        </para>
           <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/esport-talent-search">https://github.com/nbatfai/esport-talent-search</link>   
        </para>
        <programlisting language="c"><![CDATA[   
eturn a.exec();
#include <QApplication>
#include <QTextStream>
#include <QtWidgets>
#include "BrainBWin.h"
int main ( int argc, char **argv )
{
        QApplication app ( argc, argv );
        QTextStream qout ( stdout );
        qout.setCodec ( "UTF-8" );
        qout << "\n" << BrainBWin::appName << QString::fromUtf8 ( " Copyright (C) 2017, 2018 Norbert Bátfai" ) << endl;
        qout << "This program is free software: you can redistribute it and/or modify it under" << endl;
        qout << "the terms of the GNU General Public License as published by the Free Software" << endl;
        qout << "Foundation, either version 3 of the License, or (at your option) any later" << endl;
        qout << "version.\n" << endl;
        qout << "This program is distributed in the hope that it will be useful, but WITHOUT" << endl;
        qout << "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS" << endl;
        qout << "FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n" << endl;
        qout << QString::fromUtf8 ( "Ez a program szabad szoftver; terjeszthető illetve módosítható a Free Software" ) << endl;
        qout << QString::fromUtf8 ( "Foundation által kiadott GNU General Public License dokumentumában leírtak;" ) << endl;
        qout << QString::fromUtf8 ( "akár a licenc 3-as, akár (tetszőleges) későbbi változata szerint.\n" ) << endl;
        qout << QString::fromUtf8 ( "Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz, de minden" ) << endl;
        qout << QString::fromUtf8 ( "egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA VALÓ" ) << endl;
        qout << QString::fromUtf8 ( "ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve. További" ) << endl;
        qout << QString::fromUtf8 ( "részleteket a GNU General Public License tartalmaz.\n" ) << endl;
        qout << "http://gnu.hu/gplv3.html" << endl;
        QRect rect = QApplication::desktop()->availableGeometry();
        BrainBWin brainBWin ( rect.width(), rect.height() );
        brainBWin.setWindowState ( brainBWin.windowState() ^ Qt::WindowFullScreen );
        brainBWin.show();
        return app.exec();
}
      	]]></programlisting>
        <para>
            Ez ismét egy QT program. Fent csak a main.cpp látható de itt a többiről is beszélünk. Először nézzük a BraintBTheard.cpp-t. Itt áll elő a kezdő pozíció. Létrejön a mi karakterünk és 4 másik karakter. Ezek úgy vannak mindig elhelyezve, hogy mindig egymás közelébe legyenek, hogy a feladatunk ne legyen túl könnyű. A run függvény a teszt indításáért felel. Itt méri az időt is, azaz a program addig fut amíg az idő a megaditt időnl(10 perc) kisebb. Itt található még a pause függvény aminek a neve a válasz. A következő BraintBTheard.cpp található a karakterek kinézete, ezeknek a neve programon belül "hero" azaz hős.  Itt adjuk meg a nevét, az elhelyeszkedését, színét, és a mozgásának a gyorsaságát. Továbbá a többi karakter születése, gyorsasága és további információkat róluk itt adunk meg. A BrainBWin.cpp-ben megadjuk a program nevét a verzió számát. Az UpdateHeroes függvényben zajlik a kurzorunk menetének vizsgálata, itt figyeli hogy rajta vagyunk e az egérrel a karakteren, hányszor veszítettük el a karakterünk, vagy hogy éppen fut-e a teszt. Ezek utána a kövezkező függvény kirajzolja az ablakot. Itt van továbra az óra megjelenítése vagy a pontszámunkké. Ezek után jön az egér funkciói. Például ha lenyomjuk akkor elindul. Vagy az elmozdítás követése, És a billenytyűzetről bevitt karaktereket is itt dolgozza fel. 
        </para>  
        <mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/samu.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>             
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>aa
            Python
        </para>
        <para>
            Először is a Python nyelvet mutatjuk be. A nyelv egy magas színtű programozási nyelv. 1991 ben került nyilvánosság elé, amit Guido holland származású programozó fejlesztett. A python interpreteres nyelv.
        </para>
        <para>
            A Minst kézzel írott számok adatbázisa (6000 kép). Ez az alapja azoknak a programoknak ami képről ismeri fel a tárgyakat. A kézel beírt számokról a program el fogja dönteni hogy milyen szám, ez azért érdekes, mert a kézzel írott írás szinte mindenkinél más, viszont a programnak mindig tudnia kell, hogy melyik számot kell felismernie. A programhoz a TensorFlowot használjuk. A TensorFlow a Google által alkotott gépi tanulási rendszer. Sok helyen használják, az egyik leghasználtabb, az a google mapsban található utcakép.Ez neutrális háló helyett itt transzformációs gráfok találhatóak. A TensorFlow nyílt forráskódu, le kell töltenünk a használathoz. Nézzük a kódot. Először is a könyvtárakat amik kellenek, a from kulcsszóval fogjuk ezeket hozzáadni a programhoz. Utánna beimportáljuk a Tensorflow könyvtárt. Ezután következik a main. Ebben van a kiíratás felépítése, hogy hogyan küldjük ki az eredményeket (a képen látszik.). A sess azzaz egy session segítségével fogjuk a tanítást végezni, hasonlóan mint a neurális hálózatnál. Az alaposság kedvéért, hogy minél pontosabb eredményt kapjunk ezerszer futtatjuk a ciklust. Ztánna kííratjuk mennyire lett pontos az eredmény. A programban előszőr felugrik maga a kép ami a kézel írott számot taartalmazza(ehez a matplotbit-ot hasznéljuk, hogy meg tudjuk rajzolni), ha ezt bezárjuk jön a következő kép, a képeket az aktuális mappában lementjük. A programnak elég nagy a pontossága, jól felismeri. Az eredményeket egy tömben tárolja el a program.          
        </para> 
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <programlisting language="python"><![CDATA[
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import argparse
# Import data
from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf
import matplotlib.pyplot
FLAGS = None
def main(_):
  mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)
  # Create the model
  x = tf.placeholder(tf.float32, [None, 784])
  W = tf.Variable(tf.zeros([784, 10]))
  b = tf.Variable(tf.zeros([10]))
  y = tf.matmul(x, W) + b
  # Define loss and optimizer
  y_ = tf.placeholder(tf.float32, [None, 10])
  cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y, y_))
  train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)
  sess = tf.InteractiveSession()
  # Train
  tf.initialize_all_variables().run()
  print("-- A halozat tanitasa")  
  for i in range(1000):
    batch_xs, batch_ys = mnist.train.next_batch(100)
    sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})
    if i % 100 == 0:
      print(i/10, "%")
  print("----------------------------------------------------------")
  # Test trained model
  print("-- A halozat tesztelese")  
  correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))
  accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))  
  print("-- Pontossag: ", sess.run(accuracy, feed_dict={x: mnist.test.images,
                                      y_: mnist.test.labels}))
  print("----------------------------------------------------------")
  
  print("-- A MNIST 42. tesztkepenek felismerese, mutatom a szamot, a tovabblepeshez csukd be az ablakat")
  
  img = mnist.test.images[42]
  image = img
  matplotlib.pyplot.imshow(image.reshape(28, 28), cmap=matplotlib.pyplot.cm.binary)
  matplotlib.pyplot.savefig("4.png")  
  matplotlib.pyplot.show()
  classification = sess.run(tf.argmax(y, 1), feed_dict={x: [image]})
  print("-- Ezt a halozat ennek ismeri fel: ", classification[0])
  print("----------------------------------------------------------")
  print("-- A sajat kezi 8-asom felismerese, mutatom a szamot, a tovabblepeshez csukd be az ablakat")
  img = readimg()
  image = img.eval()
  image = image.reshape(28*28)
  matplotlib.pyplot.imshow(image.reshape(28, 28), cmap=matplotlib.pyplot.cm.binary)
  matplotlib.pyplot.savefig("8.png")  
  matplotlib.pyplot.show()
  classification = sess.run(tf.argmax(y, 1), feed_dict={x: [image]})
  print("-- Ezt a halozat ennek ismeri fel: ", classification[0])
  print("----------------------------------------------------------")
if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--data_dir', type=str, default='/tmp/tensorflow/mnist/input_data',
                      help='Directory for storing input data')
  FLAGS = parser.parse_args()
  tf.app.run()
        	]]></programlisting>
    </section>               

    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat: Itt el szeretném használni az első passzolási lehetőségem.
        </para>
    </section>              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
        	A lisp programozási nyelv a mesterséges inteligenciát kutatók kedvelt nyelve, eredetileg nem ez volt a célja, de hamar az MI kutatásban lett használatos. Neve jelentése a listafeldolgozás, mivel a programok felépítése láncolt lista(zárojelekkel választjuk el a listákat ). A lisp egy kifejezésorientált nyelv.
        </para>
        <para>
           Nézzük meg elsőnek Iteratív módon.     
        </para>
        <programlisting language="c"><![CDATA[
(defun faktorialisi (n)
    (do
       ((i 1 (+ 1 i))
        (prod 1 (* i prod)))
       ((equal i (+ n 1)) prod)))
        	]]></programlisting>
        <para>
        	Az elején a defun-al adjuk meg a függvény nevét és a változót amibe majd az érték érkezik. A do egy konstrukció, ezt iteratív programoknál használjuk mint ez is(iteratív struktúra). a (+ 1 i)-ben növeli az i értékét 1 el  utánna végzi el a szorzást aztán növeli az n et, amíg szükséges.
        </para>
        <para>
        	Rekurzív módon:
        </para>
        <programlisting language="c"><![CDATA[
(defun faktorialisr(n)
(if (= n 1)
    1
    (* n (faktorialisr (- n 1)))))
    ]]></programlisting>
    <para>
    	Az előző program rekurzív változata. Az elején a defunnal adjuk meg a nevet és a paramétert. Aztán if el vizsgáljuk hogy n egyenlő e 1 el, ha egyenlő akkor meghívja önmagát n-1 re és összeszorozza az n el. 
    </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>      
        </para>
    </section>        
              

    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
        A könyvben legelőször az alapfogalmakkal fogunk foglalkozni. Először is nézzük a programozási nyelveket. ezeknek 3 szintjét különböztetjük meg. Ez a három a gépi nyelv, assembly nyelv és a magasz szintű nyelv (C++,C ...stb). Minket a magasz színtű programozási nyelv fog érintetni. Az ebben írt programokat forrásprogramoknak nevezzük. Ezt a gépnek értelmeznie kell és feldolgoznia gépi nyelvre. Ezt egy fordító program segítségével jahtjuk végre, Ez először tárgyprogramot hoz létre majd ebből lesz a gépi nyelv. Az átfordításnak 4 lépése van. 1. lexikális elemzés. 2. szintaktikai elemzés. 3. szemantikai elemzés. 4.kódgenerálás. Az első lépésnél a forrást lexikális egyégekre bontjuk. A 2 lépésnél a szintaktika helyességét vizsgálja, hogy megelel e a szintaktika szabályainak. Mivel, ha nem helyes a szintaktika, nem lehet gépi nyelvet ekőállítani, ugyanis nem fogja megérteni. A 3 lépés a program megértése szemantikailag. A 4. lépés pedig legenerálni a kódot. Ezt kapja meg a vezérlő operációs rendszer. A másik technika az interpreteres technika, az első 3 lépés itt megegyezik a fordító programokkal, a különbség, hogy itt nem készül tárgyprogramot. Sorba veszi az utasításokat és sorban értelmezi azokat majd végrehajtja. Minden nyelvvnek saját hivatkozási nyelve van. Ebben van a nyelv szemantikai és szintaktikai szabáylai definiálva. A szemantikai részt emberi nyelven szokták megadni, a legelterjettebb az angol nyelv ezen a téren. A következő pontban a nyelvek osztályozásába kapunk betekintést. 2 fő osztályra bontjuk őket. Imperatív nyelvek és Deklaratív nyelvek. Az utóbbi algoritmikus nyelv, még az előbbi nem algoritmikus nyelv. A könyvben részletesen ki vannak fejtve. A következő a jelölés rendszer. A szintaktika formális leírásához alkalmazzuk ezeket. Vannak terminális én nem terminális jelölések. A jelölések után következnek a kifejezések. Ezek szintaktikai eszközök. Ezeknek van értéke és tipúsa. A kifejezések formálisan operandusokból, operátorokból és kerek zárojelekből állnak. Az operadusok a változók vagy függvény meghívása lehet. Az operátorok pedig a műveletek amit az értékekkel elvégzünk. A záró jelek egybe foglalják és a sorrendet befolyásolják. Egy ilyen kifejezésnek 3 alakját tudjuk felírn: Prefix (pl: + 7 2), infix (pl: 7 + 2), postfix (pl:  7 2 +). Az infix alakban az operátorok nem azonos errőségűek. HA egyértelmű infix kifejezést akarunk létrehozni akkor teljesen zároljeleznünk kell azt. Ez felül írja a precedencia táblázatot. A könyvben továbbá zt vizsgáljuk milyen nyelv , hogyan használja és hogyan értékeli ki a kifejezéseket. A C egy kifejezés orientált programozási nyelv. Típuskényszerítés elvét használlja. A C precedencia táblázatát is megísmerjük a könyv 51 oldalán. Pédául: [] ez a tömb operátor, . minősítő operátor, -&gt; mutatóval minősítő operátor, ++ és -- értéknövelő és csökkentő operandusok, sizeof() operátor típus vagy kifejezés hosszát adja meg. Vannak a matematikai operátorok, mint a szorzás, osztás, összeadás, kivonás. HAsonlító operátorok mint az egyenlő, nem egyenlő, nagyobb vagy egyenlő...stb. A logikai operátorok: "vagy", "kizáró vagy", "és". A könyvben ezekhez találunk leírást, hogy hogyan használjuk. Az adattípusokkal is foglalkozunk a 2.4 es pontban. Az adattípus megadja, hogy a változó milyen típusú, azaz minden típusnév egy azonosító. 3 dolog határoz meg egy adattípust: tartomyán, műveletek, reprezentáció. A programozási nyelvekben lehetőség van definiálni típusokat. Lehet létrehozni is de minden nyelvben vannak beépített típusok. Ilyen például az int azaz az egész típus, ennek vannak variánsai pédául shor vagy long int,  a bool a logikai típus, float vagy a double amik lebegőpontos számokat tudnak tárolni. A könyvben megnézzük az egyszerű és öszetett típusok. A könyvben nagy sújt kap a saját típus létrehozása. Szót kell még ejteni a tömbökröl, ezeknek is van típusa ugyan úgy mint a változóknak, a tömbök olyan típusú változókat tartalmaznak amilyen típusú a tömb, ezeken belül a tömb indexével tudunk mozogni. A mutató típust is átvesszük. A nevesített konstans egy olyan eszköz a programozásban aminek 3 része van: Név, Típus, Érték. Ezt a 3 at mindig deklarálni kell. Ugye a konstans jelentése álladnó, tehát ez a programban mindig a deklarálásnál megadott nevet, értéket és típust fogja tartalmazni. Ezeket érdemes beszélő nevekkel ellátni, és olyan értékeket adni amiket sokszor használunk. C ben ezt az alábbi módon kell: " #define név literál ". A változó a konstant "testvére" úgymond. Neki 4 komponense van, Név, attribútom, cím, érték. A váltózó ahogy a neve is mondja nem állandó. A név az azonosítója. ezzel hivatkozunk rá a programban. Az attríbutok közül a legfontosabb hogy milyen típusú, a típusokrol már fentebb beszéltünk, amilyen típusú olyan értéket tud tárolni. És tudun címet adni neki, azaz hol helyezkedjen el a tárolóban. de az elhelyezést a gép végzi, de hogy mikor hozza létre az attol függ hogy hol deklaráljuk . Nézünk egy pédát: int a=5 . ez egy egész tipusú váltózó kezdőértéke 5 a neve pedig "a". Most nézzük meg a C byelv alapelemeit. Vannak integrált típusok (int, char..stb). Származtatott típusok (tömb, függvény, union, mutató).Ezek az aritmetiaki típusok. A tömböt az alábbi módon hozzuk létre: int a[elemszám]. megadjuk a típusát a nevét és hogy hány elemű. Az utasítások a következő rész. Az utasítások alkotják a programot. Ezekblő épül fel egy algorítmus, ciklus, és szinte mindent, az utasításokat fordítja le a fordítóprogram tárgyprogramra. Kér nagyobb részre tudjuk bontani, deklarációs utasítáás és végrehajtható utasítás. A deklarációs utasítás a fordítóprogram miatt vannak. tőle kérnek szolgálltatást vagy egy üzzemmóbdba való lépést. Befolyásolja a tárgykódot de nem kerül lefordításra. A vegrehajtható utasítás, ahogy a nevében is benne van, bóvégre lehet hajtani.Ezekből lesz generálva a tárgykód. Ezeket tudjuk csoportosítani például értékeadó utasítás, üres utasítás, ugró utasítás, elágazó utasítás, hívó utasítás, I/O utasítások ...stb. Ezekről a könyvben részletes leírást kapunk. péladául az értékadó utasításban értéket adunk vagy modosítunk egy változón vagy több változón. Az elágazó utasítások is szinte kihagyhatatlanok egy programbol, ugye ezek az if és az else if feltételes utasítások. Ezek lehetővé teszik a programban a több irányú elágazást. A ciklusszervező utasításokat is ismerjük már ha nem kezdők vagyunk. Ugye ezek a for, while, do wile ciklusok. A végtelen ciklus volt az első feladatunk, azt már ismerjük, Vannak feltételes ciklusok, ugye itt addig fut a ciklus még a feltétel igaz. van kezdő feltételes ls végfeltételes ciklus.Ezeknek a működését a könyvben megismertük. Van az előírt lépésszamú ciklus (a for()). Annyiszor fut le a ciklus, ahányszor előírtuk neki. Vannak összetett ciklusok Ez az előzők kombinéciója. A működésük nagyon bonyolult. 3 vezérlő utasítás van C ben. 1. Return: Ez szabáylosan befejezzi a függvényt és vissza adja azt a vezérlést hívónak, legtöbbször értékkel tér vissza. 2. BREAK: ezt a cikluson belül alkalmazzuk, ha életbe lép akkor kilép a ciklusból és az utánna lévő cikluson belüli utasításokat nem hajtja végre. Ezt iffel szoktuk alkalmazi . 3. Continue: ez is a ciklus magban van. ez is kilép, vagy újabb cikluslépésbe kezd, vagy megvizsgálja újra az ismétlődés feltételeit. Az 5. fejezetben a programok szerkezetét ismerjük meg, hogy milyen részekből áll. Itt ismerjük meg az alprogram feladata egy bemeneti adatcsoport leképzése vagy kimeneti adatcsoportot kpez le, egy megadott specifikáció szerint. Ebben a fejezetben ismerjük megg a bklokkokat. a blokk egy programegység, ami utasításokat foglal magában. A kezdetét és végét speciális karakter jelzi. A blokk bárhol elhelyezhetó a programban. A 13. I/O fogjuk venni. Ez egy egy olyan rész ahol a program nyelvek nagyban eltérnek egymástól. Állimányuk a funkciók szerint 3 lehet. lehet input,output és input-output állomyán.
        Az I/O során a programban az adatok a tár és a periféria között mozognak. Ezeknek van egy bizonyos ébrázolási módja. Az adatátvietelnek 3 fajtáját alkalmazzuk: formátumos módú, szerkesztett modú és listázott modú adatátvietl. Ha állományokat alkalmazunk azt a következpképpen kell csinálnunk. 1. deklaráció,  2. összerendelés, 3. állomány megnyitása, 4. feldolgozás, 5. lezárás. A C-nyelvnek nem része az I/O erre egy standart könyvtárat használunk. 
        </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
       	<para>
        A könyvben a C nyelv alapjaival fogunk megismerkedni az alapoktól. A könyv programok segítségével segít elsajátítani a C nyelv ismeretét. Ha eddig egyátalán nem találkoztunk a C nyelvel, a könyv akkor is nagyon hasznos lehet, hiszen nagyon részletesen, mindenre odafigyelve adja át a tudást. Először kezdjük a változók típusaival és a program beli alkalmazásával. A programban különböző tipusú ezeken belül különbözű méretű változók vannak. Típusok: int -intiger, azaz egész típusú számot deklarálunk ezzel, mérete a gép egészétől függ. char -Ez egy karaktert tud tárolni, mérete 1 bájt. float - egyszeresen pontos lebegőpontos számot tud tárolni (törtet). double- kétszeresen pontos lebegőpontos számot tud tárolni, ezt hatalmas számokkal való számolásnál használjuk. Az int típustnak vannak fajtái még, ilyen a short int vagy a long int, van továbbá még unsigned int amivel a negatív számok helyett, csak pozitív értékeket tudunk tárolni, de abból többet mint a sima int-nél. Továbbá ami még lényeges lehet, az lokális és globális változó, ahogy a nevük is jelzi, a globális az egész programban használható, még a lokális csak a megadott helyen. A könyvben a helyes alkalmazásról rengeteg példát láthatunk. Vannak az állandók, ezeknek megadunk egy értéket, és ez az érték állandó lesz a programban, nem változik. A könyv következő fejezetében a Vezérlési szerkezetet vesszük.  Ez határozza meg , hogy milyen sorrendben hajtódnak végre a műveletek. Először az utasításokat és a blokkokat nézzük. Fontos szabály, hogy minden utasítást ";" -al zárunk le. Így válik egy sor utasítássá. Ha az utasítások {}-el vannak körbe zárva, akkor azt egy bloknak nevezzük és 1 db utasításlént kezeljük. A blokkok közé soroljuk a ciklusokat és a az elágazásokat. Először az if utasítással ismerkedünk meg. Ha a megadott feltétel igaz, akkor a megadott utasítások fognak lefutni, ha nem igaz akkor az utasításokat figyelmenkívűl hagyja. Ennek a bővítése az else-if. Itt meg tudjuk adni, hogy a program milyen utasításokat hajtson végre, ha a feltétel nem igaz. A következő a switch utasítás. A lényege hogy megadunk neki mintákat, és ha a vizsgált elem megegyezik valamelyik mintával, a mintánál megadott utasítások fognak lefutni. ezek után vegyük a ciklusókat. A ciklus egy olyan blok ami a feltételig újra és újra lefut. Kezdjük a while ciklussal, a while jelentése amíg, tehát amíg a kifejezés igaz addig lefut a ciklus, itt az lesz fontos, hogy először vizsgálja meg , hogy a feltétel igaz e, aztán fog lefutni az utasítás vagy utasítások. Ezzel megeggyezik a for utasítás, a lényege és működési elve ugyan ez. A felépítése különbözik. A do while ciklus először végrehajtja az utasítást és aztán vizsgálja meg a feltételt, ha nem igaz akkor kilép a ciklusból. A break utasíással a futás közben is kitudunk lépni egy ciklusból ezt a ciklusokban lévő if-ekben szoktok alkalmazni. A goto -val pedig egy adott cimkére ugorhatunk. De ezt nem sűrűn alkalmazzák, sokan nem is szeretik. Rendezni tudjuk ezeket a futási sorrend alapján. Van a sima ami sorban fut le, de van a cimkézett usasítás blokk az előbb említett goto-val, itt az adott feltételektőll függ, milyen sorrendben fut le a program. A Függelékben az utasításoknál csoportosítjuk az utasítások fajtáit. A címzett utasításokhot előtagként megadott cimke kapcsolódik. A kifejezésutasítás, a nevéből adódoan kifejezésekből épül fel. Az összetett utasítás megszünteti a korlátozást ahol a fordító csak egyetlen utasítást fogad el. A kiválasztó utasítások, a lehetséges esetek közül választ a feltételnek megfeleően (if, switch). A vezérlés átadó utasítások, amár fentiekben emlitett goto, continuem break, return parancsokat alkalmazza. Az Iterációs utasítások a ciklusokat alkalmazzák (while, do, for).
        </para>        
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
        A könyv témája a szoftverfejlesztés C++-ban. A legelső fejezetben azokat az új dolgokat fogjuk megnézni amiket C-ben nem tudtunk de C++ ban már lehetséges. Elsőre függvényparaméterek és visszatérési értékek vesszük. A C ben üres paraméterlistával definiált függvényt itt C++ ban void paraméter megadásával oldjuk meg.A visszatérési típusnál is eltér a 2 nyelv. Míg a C nyelvél int, addig C++ nem támpgatja az alapméretezett típust. Az int main fő függvénynek is 2 típusa van C++ -ban. Az első mikor nem adunk meg semmit, a másik mikor argumentumokat adunk a mainnak a parancssorból. A C++ nyelvben jelent meg előszőr a bool azaz a logikai típus aminek értéke true vagy false. A feladatok között van egy ahol az volt a hiba, mikor utasításon belül deklaráltunk. C++ ban már ez is lehetséges. A példa erre, hogy az i értéket a forcikluson belül deklaráljuk: "for(int i=0; i kisebb mint 10; i++)". Hasznos lehet, ha a deklarációt a felhasználás előtt végezzük. C++ ban a függvényeket a nevük és a megadott argumentumokkal azonosítjuk. Azonos nevű csak akkor lehet, ha más az argumentum lista. C-ben a paraméterátadás érték szerint történik. A megkapott érték klonózva lesz és a másolatra fogunk hivatkozni, azaz a visszatérési érték nem befolyásolja a programunkat. Ez az adott példában a könyv jól szemlélteti. Ennek C++ ban a megoldása hogy az eredeti változót fogjuk átadni mégpedig a memória címével. Ezt a referencia jellel fogjuk teljesíteni. Így a változtatások, az eredeti változón jatódnak végbe, és az új értéket kapja vissza a program. Ez a referencia C-ben nem létezik. A harmadik fejezetben megísmerjük az Objektumokat és osztályokat. A C++ nyelv egy objektumorientált nyelv, ennek alapelveivel megismerkedünk. A lényege hogy a függvényeket osztályokba foglaljuk az osztályok pédányait nevezzük objektumoknak. (objektumokkal hívjuk meg az osztályok függvényeit.) A 3.2 bekezdésben egy példán keresztül láthatjuk, az egységbezárás előnyeit. A struktúránknak így lesznek tagváltzói, és tagfüggvényei is. A tagfüggvényeket kétféle képpen adhatjuk meg. Osztálydefinícióban vagy struktúradefiníción kívül . Fontos még az adatrejtésről is beszélnünk. Így csak az osztályon belül férhetünk hozzá, külső osztály nem férhet hozzá, az értéket függvényel tudjuk kiadni. függvény és változó is lehet ilyen, ezeket a private részbe írjuk, azaz ezeket príváttá tesszük. A konstruktor onnan ismerjük fel, hogy ugyan az a neve mint az osztálynak és nem adunk típust neki, ez akkor fut le, ha meghívjuk az adott osztáylt amiben benne van, egy objektummal, ezt gakran inícializálásra használjuk. A destrukot annyiban különbözik színtaktikailag, hogy a név előtt egy '~' jel található, és autómatikusan meghívódik egy objektum befejeződésekor, ezt a memória felszabadításra szoktuk használni főként. A c-ben a dinamikus memóriafoglalás malloc-al vagy a free kulcsszavakkal történtek. A C++ ban már operátorral tudunk lefoglalni memóriát, ez a new operátor, példa: "int *pelda; pelda= new int;" később ezt a változót fel kell majd szabadítanunk, vagy memóriaszivárgás lép fel. A dinamikus adattámogatás miatt szükséges sokszor, hogy megadjuk a mutató állapotát. Ez a NULL kulcsszó. Ha az állapot NULL akkor nincsen lefoglalt adat, ha ezt nem adjuk meg akkor a new szócskával lefoglalt területre mutat. A 3.5.3 fejezetben ismerkedünk meg a másoló konstruktorral. A másolókunstruktor egy referenciát kap, amely megegyezik az osztálynak a típusával. A másolókonstruktor is rendelkezik mindennel, amivel egy egyszerű konstruktor. Ugyan úgy tudunk inicíalizálni vele objektumokat. Amiben viszont több hogy érték szerint adunk egy függvényparamétert neki, akkor a megadott változó lemásolódik, és ezt használjuk a függvény törzsében. Az osztályainknak lehetnek friend függvényei vagy osztélyai. Ez azt jelenti, hogy jogot adunk egy függvénynek vagy egy osztálynak, hogy hozzá férjen az adott osztály védett, azaz private és protected változóihoz és függvényeihez. Ezt a friend kulcsszóval tesszük lehetővé. A feljogosítandó függvény vagy osztály elé írjuk és ezzel fel is jogosítjuk. A tagváltozóknál az értékadás és az inicializálás nem ugyan az. Az inicializálás azaz alaphelyzetbe álltjuk. A létrehozásnál megadunk neki egy alap értéket. Az értékadás az az "=" jelel történik a programtol függően, ez a programon belül bárhol megtörténhet ahol a szabályok engedik. Említenünk kell a statikus tagokat, ezek a tagok az osztályhoz tartoznak és nem az osztályobjektumhoz. Továbbá lehetőségünk van struktúráknak, osztályoknak típusdefinícióra, a typedef  szóval.  A hatodik fejezetben vesszük az operátorokat és az operátortúlterhelést. A C nyelvben az operátorok műveleteket végeznek az argumentumokon. Az operátorok kiértékelési sorrendjét egy speciális szabályrendszer határozza meg, ezeket ugyan úgy mint matematikában, zárójelekkel írhatunk felül. A C++ rendelkezik új operátorokkal a C -hez képest. Ilyen a hatókör operátor aminek jelölése a "::" ezt az osztáylok hatólörének megadásánál használjuk. Ismerjük már a "*" operátor, ugye ezzel jelöljük a mutatókat. A "-&gt;" operátorral pedig mutató esetén hivatkozunk. Fontos különbség a C és a C++ között a függvénymellékhatása, A C nem képes erre, de a C++ igen. Ráadásul mivel az operátor speciális függvény ezért különböző argumetumok esetén túl tudjuk őket terhelni. A 10 es fejezet a kivitelezésről szól. Ilyen a hagyományos hibák kezelése. De mi is az a kivitelezés? A kivitelezés egy mechanizmus, amely ha hibát fedez fel, akkor a hibakezelő ágra ugrik. Ilyen a try_catch blokk. A throw kulcsal küldünk egy kidobást. a try-catch pedig elkapja, ha egy catch ág megegyezik az elkapott típussal. Ha nem kapja el, azt kezeletlen kivitelnek nevezzük. Van egymásba ágyazott try-catch blokk, így tudjuk a kidobásokat külön szinten kezelni
        </para>  
    </section>        
</chapter>    
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>

    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
        <title>OO szemlélet</title>
        <para>
	Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
        </para>
	<para>
            A következő programcsipet a JDK beéített metódusa amely megtalálható 
            a java.util.Random forrásban a nextGaussian néven.
        </para>

        <programlisting language="java"><![CDATA[
            public class NextGuassian {
		
                private double nextNextGaussian;
                private boolean haveNextNextGaussian = false;

                public double nextGaussian() {
                if (haveNextNextGaussian) {
                    haveNextNextGaussian = false;
                    return nextNextGaussian;
                } else {
                    double n1, n2, v1, v2, s;
                    do {
                        n1 = Math.random();	/// nextDouble()
                        n2 = Math.random();
                        
                        v1 = 2 * n1 - 1;   // between -1.0 and 1.0
                        v2 = 2 * n2 - 1;   // between -1.0 and 1.0
                        s = v1 * v1 + v2 * v2;
                    } while (s >= 1 || s == 0);
                    double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
                    nextNextGaussian = v2 * multiplier;
                    haveNextNextGaussian = true;
                    return v1 * multiplier;
                    }
                }
            }
        ]]></programlisting>
	<para>
            A következő kód részlet a PolarGen, amit már elöző félévből is ismerhetünk.
        </para>
	
	 <programlisting language="java"><![CDATA[
           public class PolarGenerator
{
    boolean nincsTarolt = true;
    double tarolt;
    
    public PolarGenerator()
    {
        nincsTarolt = true;
    }
    
    public double kovetkezo() 
    {
        if(nincsTarolt)
        {
            double u1, u2, v1, v2, w;
            do{
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2* u1 -1;
                v2 = 2* u2 -1;
                w = v1*v1 + v2*v2;
            } while (w>1);
            
            double r = Math.sqrt((-2 * Math.log(w) / w));
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;
            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }
public static void main(String[] args)
    {
        PolarGenerator g = new PolarGenerator();
        for (int i = 0; i < 10; ++i)
        {
            System.out.println(g.kovetkezo());
        }
    }  
}
        ]]></programlisting>
	<para>
            Ha alaposan megfigyeljük a kér kódot, akkor látható, hogy lényegében csak a változok nevei változtak meg. Tehát levonhatjuk azt a következtetést, hogy a az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua., mint a mi kódunk.
        </para>
	<para>
            Beszéljünk kicsit a programról és hogy mit csinál. Nem nagyon fogom részletezni, mivel a Welch fejezetbe már le van írva.
            A kovetkezo() nevű metódus matematikai számítás alapján hoz létre egy új számokat. Az if-ben megnézzük, hogy
            van-e már létrehozott érték, illetve ha nincs, tovább lépünk a ciklusba. Ez létrehoz 2 "véletlen" számot a random() függvénnyel. 
            Ha a szám nagyobb mint 1, a while() ciklusban matematikai számításokat végzünk, majd értéket ad a tarolt nevű változónak. Ezt 	      követően nincsTarolt valtozó logikai értékét megváltoztatja. A returnnel pedig visszaadja a létrehozott értéket.
            Ha már volt generált szám, akkor a nincsTarolt valtozó logikai értékét megváltoztatja és azt a számot adja vissza.
        </para>
	<para>
	Lássuk úgyan ezt a kódot C++ nyelven:
        </para>
	<programlisting language="c++"><![CDATA[
	#include <iostream>
#include <math.h>
#include <pthread.h>
#include <ctime>


class PolarGen
{
public:
  PolarGen()
  {
    nincsTarolt = true;
    std::srand (std::time(NULL));
  }
  ~PolarGen()
  {
  }
  double kovetkezo();
private:
  bool nincsTarolt;
  double tarolt;
};
double PolarGen::kovetkezo ()
{
  if (nincsTarolt)
  {
    double u1, u2, v1, v2, w;
        do
      {
        u1= std::rand() / (RAND_MAX +1.0);
        u2= std::rand() / (RAND_MAX +1.0);
        v1=2*u1-1;
        v2=2*u1-1;
        w=v1*v1+v2*v2;
           }
    while (w>1);
    double r =std::sqrt ((-2 * std::log(w)) /w);
    tarolt=r*v2;
    nincsTarolt =!nincsTarolt;
    return r* v1;
   }
   else
   {
    nincsTarolt =!nincsTarolt;
    return tarolt;
   }
}
int main (int argc, char **argv)
{
    PolarGen pg;
    for (int i= 0; i<10;i++)
      std::cout<<pg.kovetkezo ()<< std::endl;
    return 0;
}
	]]></programlisting>
</section>  
    

<section>
        <title>„Gagyi”</title>
        <para>
	Az ismert formális3
„while (x &lt;= t &amp;&amp; x &gt;= t &amp;&amp; t != x);” tesztkérdéstípusra adj a szokásosnál
(miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
értékekkel meg nem! A példát építsd a JDK Integer.java forrására4
, hogy a 128-nál inkluzív objektum
példányokat poolozza!
        </para>
	<para>
	A feladatban szerepeltetett feltétel azért érdekes, mivel az integerben a -128 127 intervallum előre tárolva van és a program
	az eltárolt memória címeket hasonlítja össze. Abban az esetben, ha az intervallumon kivül eső értéket veszünk fel, példa kép a -129-t
	mind két változóban, akkor a két memóriacím különbözik, ezt követően őedig, mivel a feltétel teljesül belép a végtelen ciklusba a 		program.
	</para>
    </section>        

    <section>
        <title>Yoda</title>
        <para>
            Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda conditions-t!
        </para>
        <para>
            A Yoda conditions nevezhető egy programozási "nyelv jásrásnak". A lényege, hogy a feltétel két részét megfordítjuk. Az az
	az összehasonlítandó értéket a megszokással ellentétben, nem bal oldalra, hanem jobb oldalra tesszük.
        </para>
	<programlisting language="java"><![CDATA[
	if ($value == 42) /*e helyet*/
	if (42 == $value) /*ezt írjuk*/
	]]></programlisting>
        <para>
            A nevét a jelenség onnan kapta, hogy a Star Warsból jól ismert karakter Yoda, törve beszélte az angol nyelvet.                
        </para>
	<programlisting language="java"><![CDATA[
	public class yoda {
		public static void main (String[]args)
		{
			String myString = null;
			/*if (myString.equals("foobar"))
				System.out.println("Yoda nem ért");*/
			if (!("foobar".equals(myString)))
				System.out.println("Yoda érti");
		}
	}
	]]></programlisting>
        <para>
            A fenti programrészben elértük, hogy a kommentált rész java.lang.NullpointerEx hibával leálljon, mivel a NULL-t nem tudjuk hasonlítni a karakter sorhoz.
        </para>
    </section>   
<section>
        <title>EPAM: Objektum példányosítás programozási mintákkal</title>
        <para>
            Hozz példát mindegyik “creational design pattern”-re és mutasd be mikor érdemes használni őket!
        </para>
        <para>
            A létrehozási minták a példányosítás folyamatát ábrázolja. Obijektumok létrehozására valóak és, hogy egyszerűsítsék kódot illetve 
	a tervezést.
        </para>
	<para>
	Gyártó metódus programtervezési minta
	</para>
	<para>
	Ezzel a mintával a kódban található számos egyforma példányosító utosítás kiváltható. A függvények neve általában a Create, Make vagy 
	Do szóval kezdödnek és a nevükben megadott osztály egy pédányát adják vissza. Az ősosztályban elhelyezett gyártásimetódus írja le a 
	gyártás algoritmusát, a gyermek osztály pedig eldönti mit kell legyártani.
	</para>
	<para>
	
	</para>
	<para>
	A inkelt példában az "auto" osztály egy abstact osztály lesz, ennek a mintjára adunk meg három másik osztályt, amely ezt kibővíti. 
	A "Getautomarka" osztály létre fogja hozni az obijektumot a megadott információ szerint.
	</para>
	<para>
	Absztrakt gyár programtervezési minta
	</para>
	<para>
	Ez a programozási minta lehetőséget nyújt arra, hogy a közös témához kapcsolodó gyártó metódusokat egyságbe zárjuk, anélkül, hogy specifikálnánk azok konkrét osztályiat. Szétválasztja egymástól objektumok egy csoportjának implementációját azok általános használatától és objektum összetételre hagyatkozik. Ennek a mintának a használata, lehetővé teszi egy rendszerben a konkrét típus implementációk kicserélését anélkül, hogy az őket használó kódot módosítanánk.
	</para>
	<para>
	
	</para>
	<para>
	A linkelt példában, elsőnek létrehozunk egy "bank" interfészt, majd konkrét osztályokat, minden banknak. Ezt követöen egy "kölcsön"
	abstarct osztályt és konkrét osztályokat a kölcsön tipusoknak. Majd létrehozzuk az absztract gyárunkat, ami hivatkozni fog a bank és a kölcsöngyár osztályra.
	</para>
	<para>
	Építő programtervezési minta
	</para>
	<para>
	Ez a minta a gyártó és az absztrakt gyár metodustól abban különbözik, hogy alternatívát nyújt a teleszkópos konstruktor anti-mintára.
	Az anti-minta akkor jelentkezik, amikor a konstruktor paraméter-kombinációinka a száma növekszik és a konstruktor exponenciális listáját okozza. Az építő minta az építőt használja, ami egy másik obijektum és minden egyes paramétert lépésről lépésre kap meg, majd egyben adja azt vissza. Ezt a programtervezési mintát használhatjuk lapos adatoknál. (HTML, SQL)
	</para>
	<para>
	
	</para>
	<para>
	Prototípus programtervezési minta
	</para>
	<para>
	A prototípus programozási minta lényege, a klónozás, az erefeti obijektummal megegyző új obijektum létrehozása. Ehhez az egyszerű értékadás nem elegendő, úgyan is azzal csak másolás történik. A klónozásnak két típusa van a segély és a mély klonózás. A sekély klónozásban a hivatkozott obijektumokat is másoljuk, mint elemi tipusú tulajdonságait. A mély klónozásnál az osztály által hivatkozott objektumokat is klónozzuk.
	</para>
	<para>
	
	</para>
	<para>
	Egyke programtervezési minta
	</para>
	<para>
	Ebben a programozási mintában egy obijektumra korlátozzuk, a létrehozható példányok számát. Az egykének nem lehet publikus konstruktora, mivel ez esetben több példányt is létre lehetne hozni. De ha nincs konstruktor, akkor nem hozható létre a megoldást az osztályszintű metódusok jelentik. Ezzeket akkor is lehet használni ha nincs példány. Szóval az egykének van osztály szintű metódusa, ami minden hívojának ugyan azt adja vissza. A létrehozáshoz pedig privát konstruktort
	</para>
	<para>
	
	</para>
    </section> 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
        <title>Liskov helyettesítés sértése</title>
        <para>
	Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
        </para>
	<para>
	Liskov helyetesítési elve a következő: Ha S altípusa T-nek, akkor minden olyan helyen ahol T-t felhasználjuk S-t is minden gond nélkül behelyettesíthetjük anélkül, hogy a programrész tulajdonságai megváltoznának.
	</para>
	<para>
	Ez azt jelenti, hogy az S altípus mindenhova beilleszthető ahova a T ős, illetve minden tulajdonsága úgyan az. Ez nagyon jól hangzik mert rengeteget könnyít számunkra, mikor hasonló osztályokat szeretnénk létrehozni. Azonban ezt az elvet meg lehet sérteni, és a feladatban meg is fogjuk, a következő képen: olyan osztály csinálunk, ami felesleges utasítást örök az őstől. Mind a két programban (Java és C++) úgyan azt csináljuk, ráveszük a Pingvint, hogy repüljön, ami lehetetlen.
	</para>
    	<programlisting language="java"><![CDATA[
	class Madar{
	public void repul()
	{
		System.out.println(super.getClass().getSimpleName() + " repül");
	};
}

class Sas extends Madar{};
class Golya extends Madar{}; 
class Pingvin extends Madar{};

public class liskov
{
	public static void main(String[] args)
	{
		Madar madar = new Madar();
		Sas sas = new Sas();
		Golya golya = new Golya();
		Pingvin pingvin = new Pingvin();
		sas.repul();
		golya.repul();
		pingvin.repul();
	}
}
	]]></programlisting>
	<para>
	Látható, hogy a programunkban a Pingvin osztály örökölte a Madar osztály repul függvényét, ami számára teljesen felesleges. Ezzel sértve Liskov helyetesítési elvét. A következő program úgyen ezt csinálja, csak C++ nyelven írodot.
	</para>
	<programlisting language="c++"><![CDATA[
	#include <iostream>

using namespace std;
class Madar{
	public:
		void repul(char nev[]){
		cout<<nev<<" repul\n";
			}
};

class Golya : public Madar
{
	public:	
	char nev[7]="Golya";
};
class Sas : public Madar
{
	public:
	char nev[4]="Sas";
};
class Pingvin : public Madar
{
	public:
	char nev[8]="Pingvin";
};
int main()
{
	Golya golya;
	Sas sas;
	Pingvin pingvin;
	golya.repul(golya.nev);	
	sas.repul(sas.nev);
	pingvin.repul(pingvin.nev);		
	return 0;
}
	]]></programlisting>
</section>  
    

<section>
        <title>Szülő-gyerek</title>
        <para>
	Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
        </para>
	<para>
	A következő feladatban egy programot láthatunk, amelyben a láthatjuk, hogy az alosztály képes használni az ős függvényeit, de ez fordítva nem igaz. Lássuk is a Java kódot:
	</para>
	<programlisting language="java"><![CDATA[
	class szulo{
	public void write(){
		System.out.println("Szülő");
	}
}
class gyerek extends szulo{
	public void kiir() {
		System.out.println("Gyerek");
	}
}
public class szulogyerek {
	public static void main(String[] args) {
		szulo egy = new szulo();
		gyerek ketto = new gyerek();
		egy.write();
		ketto.kiir();
		ketto.write();
	}
}
	]]></programlisting>
	<para>
	A program részletben látható, hogy a gyerek tudja használni a szulo write függvényét. Ellenben ha ezt fordítva szeretnénk eljátszani, az az egy szulo osztályú obijektumot kérnénk meg arra, hogy a gyerek osztály kiir függvényét használja, a programunk nem fordulna, kompilálási hibába ütköznénk. Most pedig úgyan ez a program C++ nyelven:
	</para>
	<programlisting language="java"><![CDATA[
#include <iostream>

using namespace std;

class Szulo{
	public: void ir(){cout<<"szulo";}
}; 

class gyerek : public Szulo
{
	public: void kiir(){
		cout<<"Gyerek";
}
};


int main()
{
	Szulo apa;
	gyerek fia;
	apa.ir();
	fia.ir();
	fia.kiir();
	//apa.kiir();
	return 0;
}
	]]></programlisting>
    </section>        

    <section>
        <title>EPAM: Liskov féle helyettesíthetőség elve, öröklődés</title>
        <para>
            Adott az alábbi osztály hierarchia.
        </para>
	<programlisting language="java"><![CDATA[
	class Vehicle, class Car extends Vehicle, class Supercar extends
Car
	]]></programlisting>
	<para>
            Mindegyik osztály konstruktorában történik egy kiíratás, valamint a Vehicle osztályban szereplő
start() metódus mindegyik alosztályban felül van definiálva.
Mi történik ezen kódok futtatása esetén, és miért?
        </para>
        <programlisting language="java"><![CDATA[
	Vehicle firstVehicle = new Supercar();
firstVehicle.start();
System.out.println(firstVehicle instanceof Car);
Car secondVehicle = (Car) firstVehicle;
secondVehicle.start();
System.out.println(secondVehicle instanceof Supercar);
Supercar thirdVehicle = new Vehicle();
thirdVehicle.start();
	]]></programlisting>
	<para>
	Elsőnek is lássuk a teljes kodót:
        </para>
	<programlisting language="java"><![CDATA[
	class Vehicle{
	public Vehicle() {
		System.out.println("Vehicle");
	};
	public void start() {
		System.out.println("first");
	}
};
class Car extends Vehicle{
	public Car() {
		System.out.println("Car");
	}
	@Override
	public void start() {
		System.out.println("second");
	}
};
class Supercar extends Car{
	public Supercar()
	{
		System.out.println("Supercar");
	}
	@Override
	public void start() {
		System.out.println("third");
	}
};
public class liskov {

	public static void main(String[] args) {
		Vehicle firstVehicle = new Supercar();
		firstVehicle.start();
		System.out.println(firstVehicle instanceof Car);
		Car secondVehicle = (Car) firstVehicle;
		secondVehicle.start();
		System.out.println(secondVehicle instanceof Supercar);
		//Supercar thirdVehicle = new Vehicle();
		//thirdVehicle.start();
	}

}
	]]></programlisting>
	<para>
	A kérdésünk az volt, hogy mi történik a kód futatását követően. Erre a válasz, hogy semmi, mivel nem fordul le a program. Az ok pedig, úgyan az, mint az elöző feladatnál. Azt szeretnénk, hogy egy ős osztály a leszármazott osztály egyik függvényét használja. Ahogy látható  a fenti kódban, az utolsó két sor kommentárba van, ezzel elérve, hogy leforduljon a program.
        </para>
    </section>   
<section>
        <title>EPAM: Interfész, Osztály, Absztrak Osztály</title>
        <para>
            Mi a különbség Java-ban a Class, Abstract Class és az Interface között? Egy tetszőleges példával /
példa kódon keresztül mutasd be őket és hogy mikor melyik koncepciót célszerű használni.
        </para>
	<para>
            Osztály :
        </para>
	<para>
            Egy osztály a következő képen hozzunk létre: class &lt; osztály neve &gt;. Az osztályban deklarálhatunk változokat illetve függvényeket, az utobbikat kötelesek vagyunk kifejteni (az az leírni, hogy mit fognak csinálni.) Az osztálynak van konstruktora is, ami a nevére hivatkozik.
        </para>
	<para>
            Egy egyszerű példa program egyszerű osztállyal:
        </para>
        <programlisting language="java"><![CDATA[
	class car2{
	public void brand() {
		System.out.println("Audi A" + 4);
	}
	public void color() {
		System.out.println("black");
	}
}

public class normalclass {

	public static void main(String[] args) {
	car2 car = new car2();
	car.brand();
	car.color();
	}

}
	]]></programlisting>
	<para>
            Interface :
        </para>
	<para>
            Egy interfészt a következő képen hozzunk létre: interface &lt; interface neve &gt;. Az interfészben deklarálhatunk változokat illetve függvényeket, az utobbikat azonban, az osztállyal ellentétben nem fejtjük ki. A függvény kifejtése majd csak az osztályon belül fog megtörténi. Az osztály úgy örökli az interfész tulajdonságait, hogy a létrehozásakor utána írjuk, hogy "implements &lt; interface neve &gt;".
Egy osztály több intefésztől is örökölhet utasításokat, ez esetben vesszővel válasszuk el az interfészek neveit az osztály deklarálásánál.
        </para>
	<para>
            Egy egyszerű példa program interfésszel:
        </para>
        <programlisting language="java"><![CDATA[
	

interface car{ //ez egy séma
	public void getbrand();
	public void getcolor();
}

class newcar implements car{ //osztalyt csinálunk a séma alapján
	public void getbrand(){
		System.out.println("Audi A" + 4);
	}
	public void getcolor() {
		System.out.println("Black");
	}
}

public class inetface {

	public static void main(String[] args) {
		newcar car= new newcar(); //példányosítás
		car.getbrand();
		car.getcolor();
	}

}
	]]></programlisting>
	<para>
            Absztract osztály :
        </para>
	<para>
            Egy absztrakt osztályt a következő képen hozzunk létre: abstract &lt; osztály neve &gt;. Az absztrakt osztályban deklarálhatunk változokat illetve függvényeket. A függvényekkel azonban azt teszünk, amit akarunk, az az vagy kifejtjük, vagy nem ez a programozon áll, azonban amennyiben nem fejtjük ki, akkor elé kell írni az abstract kulcs szót. Az osztály úgy örökli az absztrakt osztály tulajdonságait, hogy a létrehozásakor utána írjuk, hogy "extends &lt; absztrakt osztály neve &gt;".
Egy osztály csak és csak is egy absztrakt osztálytól örökölhet.
        </para>
	<para>
            Egy egyszerű példa program absztrak osztállyal:
        </para>
        <programlisting language="java"><![CDATA[
	


abstract class car1{ //ez egy séma
	public abstract void getbrand();
	public void getcolor()
	{
		System.out.println("Black");
	}
}

class newcar1 extends car1{ //osztalyt csinálunk a séma alapján
	public void getbrand(){
		System.out.println("Audi A" + 4);
	}
}

public class abstract1{

	public static void main(String[] args) {
		newcar1 car= new newcar1(); //példányosítás
		car.getbrand();
		car.getcolor();
	}

}
	]]></programlisting>
    </section> 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
</chapter>   

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
        <title>Forward engineering UML osztálydiagram</title>
        <para>
	UML-ben tervezzünk osztályokat és generáljunk belőle forrást!
        </para>
	<para>
            A feladatban a GenMyCode nevezetü weboldalt fogom használni, ahol meg lehet építeni az UML fát, majd legenerálni vele az osztály fájlokat.
        </para>
	<para>
            Jelenleg egy egyszerű példát fogok létrehozni, amiben van két osztály, az egyikben a Bankszámla  adatokat, illetve a pénzfelvétel lesz, a másikban pedig bankszámlát hozzunk létre. Az UML a következő képen nézz ki:
        </para>

	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/uml.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>

	<para>
            Az UML megszerkeztése utaán a következő feladatunk legenerálni az osztályokat. Ha a fentebb említett GenMyCode nevezetű online felületet használjuk, akkor ez számunkra nagyon egyszerű. Bal oldalt menüpontot váltunk a Generators fülre kattintva. Itt a két megjelent mappából a következő útvonalon haladunk: Sample generators/UML/Java és én itt az uml2java generátort használtam. Erre katintva, egy új fül nyilik meg a munka felületen, egy hosszú kód amit, ha futattunk, akkor legenerálja és le is tölti az osztályokat.
        </para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/generalt.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
	<para>
	A fenti képen látható az egyik osztály, amit generáltunk. Észrevehető a rengetek megjegyzés mellett, hogy a változok neve tényleg az, amit megadtunk az UML ábrán. Innen a következő feladatunk definiálni a függvényeket és egy futatható programot írni. Nem szeretném nagyon részletezni a kódot, a lényege, hogy létrehozz egy bankszámlafiókot egy előre beépített összeggel rajta, és erről lehet készpénzt lekérni.
        </para>

        <programlisting language="java"><![CDATA[
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
//Bankszamla.java
public class Bankszamla {

	public String Szamlaszam;
	public int Osszeg = 60000;

	public Bankszamla() {
		super();
	}

	public void Egyenleg(int parameter) {
		System.out.println("Az on egyenlege:" + parameter);
	}

	public int Lekeres() {
		System.out.println("Írja be a kivenni kivánt összeget.");
		String levon;
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try {
			levon = br.readLine();
			int levonas = Integer.parseInt(levon);
			if (levonas < 0)
				System.out.println("Érvénytelen összeg");
			else if (levonas > Osszeg)
				System.out.println("Nem áll rendelkezésre elég összeg");
			else {
				Osszeg = Osszeg - levonas;
				System.out.println("Sikeres tranzakció");
			}
		} catch (IOException e) {
			System.out.println("Nem adott meg összeget");
		}

		return 0;
	}

}
        ]]></programlisting>
	 <programlisting language="java"><![CDATA[
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
//Szemely.java
public class Szemely
{

	public String Szemelyiszam;
	
	public String Nev;
	
	public Szemely(){
		super();
	}
	
	public void AddAccount(Bankszamla parameter) {
		System.out.println("Adja meg a szemelyi azonosító számát!");
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try {
			Szemelyiszam=br.readLine();
		} catch (IOException e) {
			System.out.println("Nem adott meg adatot");
		}
		System.out.println("Adja meg a nevét!");
		try {
			Nev=br.readLine();
		} catch (IOException e) {
			System.out.println("Nem adott meg adatot");
		}
		
	}
	
}
        ]]></programlisting>
</section>  
    

<section>
        <title>EPAM: Neptun tantárgyfelvétel modellezése UML-ben</title>
        <para>
	Modellezd le a Neptun rendszer tárgyfelvételéhez szükséges objektumokat UML diagramm
segítségével.
        </para>
	<para>
	Az elöző feledathoz hasonlóan itt is egy UML táblát fogunk létrehozni, ahol szintén a GenMyCode weboldalt fogom használni, az egyszerűbb kivitelezés céljából. Az UML tábla a következő képen nézz ki:
	</para>
	<mediaobject>
        	<imageobject condition="printf">
        		<imagedata fileref="img/neptun.png" format="PNG" scale="30"/>
        	</imageobject>
        </mediaobject>
	<para>
	Induljunk a főosztálytól, ami a Neptun lesz, úgyan is ebben található a main függvény. Ez fogja használni a Targy abstract osztályt, aminek van két változója (ferohely, csoport) és három függvénye(getHely, getRand, eredmeny). Ezt az abstract osztály három tantárgy osztály fogja örökölni (Prog2, Statisztika, Szamitastudomany), amelyeknek van két-két függvénye. A GetTargynev osztály, pedig egy fügvényel rendelkezik, ami visszadja az egyes tantárgyak nevét.
        </para>
    </section>        

    <section>
        <title>EPAM: Neptun tantárgyfelvétel UML diagram implementálása</title>
        <para>
            Implementáld le az előző feladatban létrehozott diagrammot egy tetszőleges nyelven.
        </para>
        <para>
            Hogy meggyorsítsük kicsit a feladatunk az elöző feladatban létrehozott UML táblát legenerálom, ahogy az első feladatban leírtam. Így az osztályok létre vannak hozzva és csak a függvényeket kell kifejeteni, illetve a program és felhasználó közötti kommunikációt kell létre hozni.
        </para>
	<programlisting language="java"><![CDATA[
public abstract class Targy
{
	protected int ferohely;
	protected int csoport;
	
	public abstract void getHely() ;
		
	public abstract int getRand() ;
	
	public void eredmeny(String muvelet, String nev) {
		if (muvelet.equalsIgnoreCase("Felvesz"))
		{
			if(getRand() < csoport * ferohely)
System.out.println("Sikeresen felvetted a " + nev + " tárgyat a " + (int) (Math.random() * (csoport - 1) + 1 ) + ". csoportba.");
			else
				System.out.println("A kurzusok beteltek.");
			for(int i=1; i<=csoport; i++) {
				System.out.println(i+". csoport: " + ferohely + "/" + ferohely);
			}
		}
		else if(muvelet.equalsIgnoreCase("LEAD")) {
			System.out.println("Sikeresen leadtad a " + (int) (Math.random() * (csoport - 1) + 1 ) + ". " + nev + " csoport tárgyát.");
		}
		else 
			System.out.println("Nincs ilyen parancs. Próbáld újra.");
	}
	
}

	]]></programlisting>
	<para>
            A fenti kód részlet az abstract Targy osztályunk kifejtése. A legenerálásnak köszönhetően, a feladatunk itt csak az "eredmeny" függvény kifejtése. Ez a függvény annyit tesz, hogy kiírja sikeres volt-e a tárgyfelvétel és leadás vagy nem. Ha rossz parancsot gépelünk be, akkor, hiba üzenetet küldünk vissza, ezzel értesítve a felhasználót, hogy olyan utasítást szeretne végrehajtani, amit nem lehetséges.
        </para>        
	<para>
            Mivel a tantárgyakat szimbolizáló osztályok felépítése és müködése úgyan olyan, egyszere ki lehet fejteni mind a hármat. Ahogy a következő kódrészletben látható lesz, a getRand vissza ad egy int számot, ami azt fogja jelképezni, hogy hányan vették fel az adott tantárgyat. Ez a szám véletlen szerű lesz a következő képletet használva: (Math.random() * (felső határérték) - (alsó határérték+1)) + (alsó határérték). A getHely pedig a férőhelyek számát adja vissza. Akkor lássuk a három osztályt:
        </para>   
	<programlisting language="java"><![CDATA[
public class Prog2 extends Targy
{	
	public int getRand() {
		return (int) ((Math.random() * (120-60+1)) + 60);	
	}
	
	public void getHely() {
		ferohely = 18;
		csoport = 5;
	}
	
}
	]]></programlisting>
	<programlisting language="java"><![CDATA[
public class Statisztika extends Targy
{
	public int getRand() {
		return (int) ((Math.random() * (100-70+1)) + 70);	
	}
	
	public void getHely() {	
		ferohely = 22;
		csoport = 4;
	}
	
}

	]]></programlisting>
	<programlisting language="java"><![CDATA[
public class Szamitastudomany extends Targy
{
	public int getRand() {
		return (int) ((Math.random() * (100-70+1)) + 70);	
	}
	
	public void getHely() {
		
	}
	
}

	]]></programlisting>
	<para>
            A GetTagynev osztályban létrehozunk egy listát, amiben eltároljuk az összes tárgyat, majd ezt követően a beolvasot tárgynevet összehasonlítjuk a lista elemekkel. Ha találat van a listában, visszadja a tárgy nevét, ellenkező esetben egy null értéket.
        </para>
	<programlisting language="java"><![CDATA[
import java.util.ArrayList;

public class GetTargynev
{
	public Targy getnev(String nev) {
		ArrayList<String> targyak = new ArrayList<String>();
		targyak.add("statisztika");
		targyak.add("prog2");
		targyak.add("Szamitastudomany");
		
		String vantargy = null;
		
		for(String i : targyak) {
			if(nev.equalsIgnoreCase(i))
				vantargy = nev;
		}
		if(vantargy != null) {
			if(nev.equalsIgnoreCase("PROG2")) {
				return new Prog2();
			}
			else if(nev.equalsIgnoreCase("STATISZTIKA")) {
				return new Statisztika();
			}
			else if(nev.equalsIgnoreCase("SZAMITASTUDOMANY")) {
				return new Szamitastudomany();
			} 
		} else {	
			System.out.println("Helytelen tárgynév vagy mûvelet.");	
		}
		return null;
	}
}

	]]></programlisting>
	<para>
            A fő osztályban, az az a Neptunban, a program kommunikál a felhasználóval, beolvassa a tárgyat illetve, hogy mit szeretne tenni a tanuló az adott tárgyal (felvenni vagy leadni). Abban az esetben, ha rossz tárgy nevet adunk hiba üzenetet kapunk és újra indul az adatok beolvasása.
        </para>
	<programlisting language="java"><![CDATA[
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Neptun {
	public static void main(String[] args) throws IOException {
		GetTargynev targyMelyik = new GetTargynev();
		BufferedReader targyfelvetel = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("Tárgyfelvétel\n");
		System.out.println("Ha végeztél ird be az 'exit' kilcsszót.");
		boolean fut;

		do {

			System.out.println("Ird be egy tárgy nevét ( prog2, statisztak, szamitastudomany ) : ");
			String targynev;
			try {
				targynev = targyfelvetel.readLine();
				System.out.println("Felvesz vagy Lead?: ");
				String muvelet = targyfelvetel.readLine();
				
				Targy t = (Targy) targyMelyik.getnev(targynev);

				if(t != null)
				{
					t.getRand();
					t.getHely();
					t.eredmeny(muvelet, targynev);
				}
				else
					System.out.println("Érvénytelen tárgynév");
				System.out.println(
						"Ha nem akarsz további mûveleteket végezni\nird be az 'exit' kulcsszót egyébként nyomj entert:");
				String exit = targyfelvetel.readLine();
				if (exit.equalsIgnoreCase("EXIT"))
					fut = false;
				else
					fut = true;
			} catch (IOException e) {
				System.out.println("Érvénytelen utasítás");
			}
			System.out.println(
					"Ha nem akarsz további mûveleteket végezni\nird be az 'exit' kulcsszót egyébként nyomj entert:");
			String exit = targyfelvetel.readLine();
			if (exit.equalsIgnoreCase("EXIT"))
				fut = false;
			else
				fut = true;
		} while (fut == true);

		System.out.println("A tárgyfelvétel megtörtént.");
	}

}
	]]></programlisting>
    </section>   
<section>
        <title>EPAM: OO modellezés</title>
        <para>
            Írj egy 1 oldalas esszét arról, hogy OO modellezés során milyen elveket tudsz követni (pl.: SOLID,
KISS, DRY, YAGNI)
        </para>
        <para>
            Ebben a feladatban az obijektum orientált programozás egyes elveíről olvashatunk. Kezdjük is a SOLID-val.
        </para>
	<para>
            Elsőnek is lássuk, honnan kapta a nevét ez az elv. A SOLID öt tervezési alapelv kezdőbetűiből alkotott mozaik szó. Az öt alap elv Egyetlen felelőség elve (Single Responsibility Principle), Nyílt/zárt elv (Open/Closed Principle), Liskov helyetesítési elve (Liskov substitution Principle), Interfész elválasztási elv (Interface Degregation Principle) illetve a Fűggőség megfordítási elv (Dependency Inversion Principle). Beszéljünk most kicsit ezzekről az elvekről.
        </para>
	<para>
            Egyetlen felelőség elve: Az elv azt mondja, hogy egy osztálynak vagy obijektumnak csak egyetlen egy oka legyen változni. Ez az egyetlen ok azt jelenti, hogy egyetlen feladata lehet csak az obijektumnak. Ha több feladattal rendelkezik, akkor ezzek csatoltá válnak, több oka lesz a változásra, illetve egy felelőségben (okban) történő változás, gátolhatja vagy gyengítheti az osztály képességét a többi feladat végrehajtásában.
        </para>
	<para>
            Nyílt/zárt elv: Az elv szerint az osztály vagy modul nyílt a kiterjeztésre az az kiterjeszthető a viselkedése, de zárt a modosításra, tehát a kiterjesztés nem változtatja meg a forrás vagy bináris kódját. Az elöző fejezetben ilyen volt a gyártó metódus. 
        </para>
	<para>
            Liskov helyetesítési elve: Szerintem ezt az elvet mindenki ismeri, de azért írjuk le mit is jelent. Az elv azt mondja ki, hogy ha S típus a T altípusa, nem változhat meg a program műkődése, ha a programban a T típusu elemeket S típussal helyetesítjük.
        </para>
	<para>
            Interfész elválasztási elv: Az elv szerint nem szabad rákényszeríteni az osztályokat arra, hogy olyan metódusoktól függjenek, amit nem is használnak. Itt meg szeretnék írni két fogalomról, ami ide tartozik. Az első a Vastag interfész (Fat Interface), amit azokra az osztályokra használunk, amelyeknek a szükségesnél több tagfüggvénnyel és baráttal rendelkezik. Az említett elv, ezzek szétválasztásával foglalkozik, az az megpróbálja az osztály több osztályra bontani, azon módon, hogy az új osztályok csak egy-egy klienst szolgáljanak ki. A másik fogalom pedig az Interfész szennyezés (interface pollution), ami azt jelenti, hogy az interfész felesleges metódusokat tartalmaza "szennyezve" van.
        </para>
	<para>
            Fűggőség megfordítási elv: Az elv azt mondja ki, hogy a magas szintű modulok ne fűggjenek az alacsony szintű moduloktól, hanem mindkettő absztrakciótól függjön. Az absztrakció pedig ne fűggjön a részletektől, hanem fordítva legyen. A magas szintű modulok adják az alkalmazás identitását. Erre a megfordításra több ok miatt is szükség volt. Az első, hogy ha nem történt volna a megfordítás, az alacsony szintű modulok megváltoztatása kihatással lett volna a magas szintű modlokra (már pedig ezzek határozák meg a programot). A magas szintű modulokat szeretnék többször újra felhasználni, ha ezzek fűggnek az alacsony szintű moduloktól, a dolgunk jóval nehezebb, úgyan is ez esetben ezzeken keresztül kellene hivatkoznunk.
        </para>
	<para>
            Egy másik modellezési elv a KISS (Keep it simple, stupid), aminek a célja az egyszerűségre való törekvés.
        </para>
	<para>
            Szintén modellezési elv a DRY (Don't Repeat Yourself). Ahogy az angol nevéből következtetni lehet, a lényege, hogy próbáljuk meg nem ismételni magunkat. Itt szeretném megemlíteni az ismétlés pár fajtáját: Kényszerített ismétlés (imposed duplication), a fejlesztő úgy érzi, hogy a környezet megköveteli az ismétlést; Nem szándékos ismétlés (inadvertent duplication) a fejlesztő nem veszi észre, hogy információt dublikál; Türelmetlen ismétlés (impatient duplication) a fejlesztő lustaságból ismétel; Fejlesztők közötti ismétlés (interdeveloper duplication) egy csapatban vagy több különböző csapatban többen dublikálnak egy információt. A DRY ellentétje a WET (We Enjoy Typing).
        </para>
	<para>
            Az utolsó modellezési elv, amiről írni szeretnék a YAGNI (You aren't gonna need it). Az elv lényege, hogy ne deklaráljunk előre semmit, ha nem használjuk fel azonnal.
        </para>
    </section> 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>   
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

	<section>
        <title>EPAM: Bináris keresés és Buborék rendezés implementálása</title>
        <para>
            Egy java osztály implementálása, amely képes előre definált n darab egész szám tárolására. Ez az osztály 
            az alábbi funkcionalitásokkal rendelkezik:
        </para>
                <para>Elem hozzáadása a tárolt elemekhez.</para>
                <para>Egy tetszőleges egész számról megállapíja, hogy el van-e tárolva.</para>
                <para>Az eltárolt elemeket rendezni tudja és visszatérni a rendezett elemekkel.</para>
        <para>
            A porgram kód pedig a következő:
        </para>

        <porgramlisting language="java"><![CDATA[
            import java.util.Arrays;

            public class IntTarolo {
                
                int array[];
                int index;
                int size = 0;
                boolean sorted = true;
                
                public IntTarolo(int size){
                    
                    this.size = size;
                    this.array = new int[size];
                }
                
                public IntTarolo(int array[]){
                    
                    this.size = array.length;
                    this.array = array;
                    this.index = this.size;
                    this.sorted = false;
                }
            ]]></porgramlisting>
        <para>
            Az osztály változóinak létrehozása és konstruktorai.
        </para>


        <porgramlisting language="java"><![CDATA[
                public void add(int ertek) {
                    if( size <= index ) {
                        throw new IllegalArgumentException("Tele van.");
                    }
                    sorted = false;
                    array[index++] = ertek;
                }
            ]]></porgramlisting>

        <para>
            A függvény amely segitségével új elemeket tárolunk el.
        </para>

        <porgramlisting language="java"><![CDATA[
                public String taroltE(int ertek) {
                    if(!sorted) {
                        sort();
                    }
                    
                    int left = 0, right = size - 1;
                    
                    while(left <= right) {
                        int mid = left + ( right - left ) / 2;
                        
                        if(array[mid] == ertek) {
                            return "A(z) " + ertek + " benne van.";
                        }
                        
                        if(array[mid] < ertek) {
                            left = mid + 1;
                        } else {
                            right = mid - 1;
                        }
                    }
                    
                    return "A(z) " + ertek + " nincs benne.";
                }
                
                public int[] sort() {
                    for(int i=0; i < size - 1; ++i) {
                        for(int j=0; j < size - i - 1; ++j) {
                            if(array[j] > array[j + 1]) {
                                int temporary = array[j];
                                array[j] = array[j + 1];
                                array[j + 1] = temporary;
                            }
                        }
                    }
                    
                    sorted = true;
                    return array;
                }
                ]]></porgramlisting>
            <para>
                A bináris kereső függvény amely logikai értéknek megfelelően adja vissza, hogy egy elem tárolt-e vagy sem.
            </para>
            <para>
                A buborékrendezés alapján rendezést végző sort() fűggvény.
            </para>

            <porgramlisting language="java"><![CDATA[
                @Override
                public int hashCode() {
                    final int prime = 23;
                    int result = 1;
                    result = prime * result + Arrays.hashCode(array);
                    return result;
                }

                @Override
                public boolean equals(Object obj) {
                    if (this == obj) {
                        return true;
                    }
                    if (!(obj instanceof IntTarolo)) {
                        return false;
                    }
                    IntTarolo other = (IntTarolo) obj;
                    return Arrays.equals(array, other.array);
                }

                @Override
                public String toString() {
                    return this.getClass().getSimpleName() + ": " + Arrays.toString(array);
                }
                
            }
            ]]></porgramlisting>
        <para>
            A fölüldefiniálások, és beépített függvények optimalizálása a programra nézve.
        </para>

    </section>


    <section>
        <title>EPAM: Order of everything</title>

        <para>
            Olyan metódust fogunk ebben a feladatban megnézni, amely tetszőleges Collection esetén vissza adja az elemeket
            egy List-ben növekvően rendezve, amennyiben az elemek összehasonlíthatóak velük azonos típusú objektumokkal.
        </para>
        <para>  
            Ha ez a feltétel nem teljesül a futáskor syntax error-t eredményez.
        </para>

        <porgramlisting language="java"><![CDATA[
            import static org.hamcrest.MatcherAssert.assertThat;
            import static org.hamcrest.Matchers.equalTo;

            import java.util.Collection;
            import java.util.Collections;
            import java.util.List;
            import java.util.Set;
            import java.util.stream.Collectors;
            import java.util.stream.Stream;

            import org.junit.jupiter.params.ParameterizedTest;
            import org.junit.jupiter.params.provider.Arguments;
            import org.junit.jupiter.params.provider.MethodSource;

            public class OrderOfEverythingTest {

                @ParameterizedTest
                @MethodSource("collectionsToSortDataProvider")
                public void testOrderShouldReturnExpectedListWhenCollectionIsPassed(Collection<Integer> input, List<Integer> expectedOutput) {
                    // Given as parameters

                    // When
                    // createOrderedList(List.of(new OrderOfEverythingTest()));
                    // ^ ez piros, az OrderOfEverythingTest nem implementálja a Comparable<OrderOfEverythingTest> -et
                    List<Integer> actualOutput = createOrderedList(input);

                    // Then
                    assertThat(actualOutput, equalTo(expectedOutput));
                }

                private static Stream<Arguments> collectionsToSortDataProvider() {
                    return Stream.of(
                        Arguments.of(Collections.emptySet(), Collections.emptyList()),
                        Arguments.of(Set.of(1), List.of(1)),
                        Arguments.of(Set.of(2,1), List.of(1,2))
                    );
                }

                private <T extends Comparable<T>> List<T> createOrderedList(Collection<T> input) {
                    return input.stream()
                        .sorted()
                        .collect(Collectors.toList());
                }
            }
        ]]></porgramlisting>

            <para>
            A következő sor syntax errort eredményez:
        </para>
        <porgramlisting language="java"><![CDATA[ 
            List<Integer> actualOutput = createOrderedList(input);
            ]]></porgramlisting>
    </section>


    <section>
        <title>EPAM: HashMap implementáció</title>

        <para>
            Egy java.util.Map implementáció, mely nem használja a Java Collection API-t.
            Az implementáció megfelel az összes megadott unit tesztnek, nem tud kezelni null
            értékű kulcsokat és a “keySet”, “values”, “entrySet” metódusok nem kell támogatják az elem törlést.
        </para>
        <para>
            Hash map használatához utánanézés szükségeltetik.
        </para> 
        <para>
            Azt,hogy működjön minden unit tesztre, a C++-ból jól ismert template osztályként definiálással érjük el. 
        </para>

        <porgramlisting language="java"><![CDATA[
            class ArrayMap<K, V> implements Map<K, V> {

            private static final int INITIAL_SIZE = 16;
            private static final String NULL_KEY_NOT_SUPPORTED = "This Map implementation does not support null keys!";

            private int size = 0;
            private K[] keys = (K[]) new Object[INITIAL_SIZE];
            private V[] values = (V[]) new Object[INITIAL_SIZE];

            @Override
            public int size() {
                return size;
            }

            @Override
            public boolean isEmpty() {
                return size <= 0;
            }

            @Override
            public boolean containsKey(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                return searchItemInArray(key, keys, Object::equals) != -1;
            }

            @Override
            public boolean containsValue(Object value) {
                int valueIndex = searchItemInArray(value, values, Object::equals);
                return valueIndex > -1 && keys[valueIndex] != null;
            }

            @Override
            public V get(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);
                if(size <= 0) {
                return null;
                }

                int keyIndex = searchItemInArray(key, keys, Object::equals);
                if (keyIndex > -1) {
                return values[keyIndex];
                }

                return null;
            }

            @Override
            public V put(K key, V value) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                int keyIndex = searchItemInArray(key, keys, Objects::equals);
                if (keyIndex < 0) {
                keyIndex = findFirstEmptyPlace();
                if (keyIndex < 0) {
                    expandArrays();
                }
                keyIndex = size;
                }

                V prevValue = values[keyIndex];

                keys[keyIndex] = key;
                values[keyIndex] = value;
                size++;

                return prevValue;
            }

            @Override
            public V remove(Object key) {
                Objects.requireNonNull(key, NULL_KEY_NOT_SUPPORTED);

                int keyIndex = searchItemInArray(key, keys, Object::equals);
                if (keyIndex > -1) {
                V prevValue = values[keyIndex];

                keys[keyIndex] = null;
                values[keyIndex] = null;
                size--;

                return prevValue;
                }

                return null;
            }

            @Override
            public void putAll(Map<? extends K, ? extends V> m) {
                m.forEach(this::put);
            }

            @Override
            public void clear() {
                Arrays.fill(keys, null);
                Arrays.fill(values, null);
                size = 0;
            }

            @Override
            public Set<K> keySet() {
                Set<K> result = new HashSet<>();
                for(K i : keys) {
                if (i != null) {
                    result.add(i);
                }
                }

                return result;
            }

            @Override
            public Collection<V> values() {
                Collection<V> result = new ArrayList<>();
                for(V i : values) {
                if (i != null) {
                    result.add(i);
                }
                }

                return result;
            }

            @Override
            public Set<Entry<K, V>> entrySet() {
                Set<Entry<K, V>> result = new HashSet<>();
                for(int i = 0; i < keys.length; ++i) {
                K key = keys[i];
                if (key != null) {
                    V value = values[i];
                    result.add(new AbstractMap.SimpleEntry<>(key, value));
                }
                }

                return result;
            }


            private <I> int searchItemInArray(I item, I[] array, BiPredicate<I, I> equalFunction) {
                for (int index = 0; index < array.length; index++) {
                if (equalFunction.test(item, array[index]))
                    return index;
                }

                return -1;
            }

            private int findFirstEmptyPlace() {
                return searchItemInArray(null, keys, Objects::equals);
            }

            private void expandArrays() {
                int expandedSize = size * 2;

                keys = Arrays.copyOf(keys, expandedSize);
                values = Arrays.copyOf(values, expandedSize);
            }

            }
        ]]></porgramlisting>

        <para>
            Több beépített függvényt felüldefiniálunk és a benne lévő tipusokat a K és V templates tipusokra cserélünk.
        </para>
    </section>


    <section>
        <title>Perceptron osztály</title>

        <para>
            A Perceptron a neuron idegsejt megfelelője a mesterséges inteligenciában. 
            Ezt tanulásra szokták alkalmazni, ugyanis képes feldolgozni és mintákat
            megtanulni, tehát a bemenetet is, ami 0,1 bol áll.
        </para>

        <para>
            Megoldás forrása:
                <link xlink:href=""/>
        </para>

        <porgramlisting language="java"><![CDATA[
            #include <iostream>
            #include "mlp.hpp"
            #include "png++/png.hpp"

            int main (int argc, char **argv) {

                png::image <png::rgb_pixel> png_image (argv[1]);
                int size = png_image.get_width()*png_image.get_height();

                Perceptron* p = new Perceptron(3, size, 256, 1);

                double* image = new double[size];

                for(int i {0}; i<png_image.get_width(); ++i)
                    for(int j {0}; j<png_image.get_height(); ++j)
                        image[i*png_image.get_width()+j] = png_image[i][j].red;

                double value = (*p) (image);

                std::cout << value << std::endl;

                delete p;
                delete [] image;
            }
        ]]></porgramlisting>

        <para>
            A program elején szükségünk lesz három darab könyvtárra. 
        </para>

        <para>
            Szokásosan az iostream-et. Aztán a megjelenítés miatt az mlp.hpp re a perceptron miatt lesz szükség, 
            míg a png++/png.hpp a png formátumú képpel való munka miatt kell.
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>       
	
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
