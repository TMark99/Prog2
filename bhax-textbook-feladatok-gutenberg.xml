<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
        A könyvben legelőször az alapfogalmakkal fogunk foglalkozni. Először is nézzük a programozási nyelveket. ezeknek 3 szintjét különböztetjük meg. Ez a három a gépi nyelv, assembly nyelv és a magasz szintű nyelv (C++,C ...stb). Minket a magasz színtű programozási nyelv fog érintetni. Az ebben írt programokat forrásprogramoknak nevezzük. Ezt a gépnek értelmeznie kell és feldolgoznia gépi nyelvre. Ezt egy fordító program segítségével jahtjuk végre, Ez először tárgyprogramot hoz létre majd ebből lesz a gépi nyelv. Az átfordításnak 4 lépése van. 1. lexikális elemzés. 2. szintaktikai elemzés. 3. szemantikai elemzés. 4.kódgenerálás. Az első lépésnél a forrást lexikális egyégekre bontjuk. A 2 lépésnél a szintaktika helyességét vizsgálja, hogy megelel e a szintaktika szabályainak. Mivel, ha nem helyes a szintaktika, nem lehet gépi nyelvet ekőállítani, ugyanis nem fogja megérteni. A 3 lépés a program megértése szemantikailag. A 4. lépés pedig legenerálni a kódot. Ezt kapja meg a vezérlő operációs rendszer. A másik technika az interpreteres technika, az első 3 lépés itt megegyezik a fordító programokkal, a különbség, hogy itt nem készül tárgyprogramot. Sorba veszi az utasításokat és sorban értelmezi azokat majd végrehajtja. Minden nyelvvnek saját hivatkozási nyelve van. Ebben van a nyelv szemantikai és szintaktikai szabáylai definiálva. A szemantikai részt emberi nyelven szokták megadni, a legelterjettebb az angol nyelv ezen a téren. A következő pontban a nyelvek osztályozásába kapunk betekintést. 2 fő osztályra bontjuk őket. Imperatív nyelvek és Deklaratív nyelvek. Az utóbbi algoritmikus nyelv, még az előbbi nem algoritmikus nyelv. A könyvben részletesen ki vannak fejtve. A következő a jelölés rendszer. A szintaktika formális leírásához alkalmazzuk ezeket. Vannak terminális én nem terminális jelölések. A jelölések után következnek a kifejezések. Ezek szintaktikai eszközök. Ezeknek van értéke és tipúsa. A kifejezések formálisan operandusokból, operátorokból és kerek zárojelekből állnak. Az operadusok a változók vagy függvény meghívása lehet. Az operátorok pedig a műveletek amit az értékekkel elvégzünk. A záró jelek egybe foglalják és a sorrendet befolyásolják. Egy ilyen kifejezésnek 3 alakját tudjuk felírn: Prefix (pl: + 7 2), infix (pl: 7 + 2), postfix (pl:  7 2 +). Az infix alakban az operátorok nem azonos errőségűek. HA egyértelmű infix kifejezést akarunk létrehozni akkor teljesen zároljeleznünk kell azt. Ez felül írja a precedencia táblázatot. A könyvben továbbá zt vizsgáljuk milyen nyelv , hogyan használja és hogyan értékeli ki a kifejezéseket. A C egy kifejezés orientált programozási nyelv. Típuskényszerítés elvét használlja. A C precedencia táblázatát is megísmerjük a könyv 51 oldalán. Pédául: [] ez a tömb operátor, . minősítő operátor, -> mutatóval minősítő operátor, ++ és -- értéknövelő és csökkentő operandusok, sizeof() operátor típus vagy kifejezés hosszát adja meg. Vannak a matematikai operátorok, mint a szorzás, osztás, összeadás, kivonás. HAsonlító operátorok mint az egyenlő, nem egyenlő, nagyobb vagy egyenlő...stb. A logikai operátorok: "vagy", "kizáró vagy", "és". A könyvben ezekhez találunk leírást, hogy hogyan használjuk. Az adattípusokkal is foglalkozunk a 2.4 es pontban. Az adattípus megadja, hogy a változó milyen típusú, azaz minden típusnév egy azonosító. 3 dolog határoz meg egy adattípust: tartomyán, műveletek, reprezentáció. A programozási nyelvekben lehetőség van definiálni típusokat. Lehet létrehozni is de minden nyelvben vannak beépített típusok. Ilyen például az int azaz az egész típus, ennek vannak variánsai pédául shor vagy long int,  a bool a logikai típus, float vagy a double amik lebegőpontos számokat tudnak tárolni. A könyvben megnézzük az egyszerű és öszetett típusok. A könyvben nagy sújt kap a saját típus létrehozása. Szót kell még ejteni a tömbökröl, ezeknek is van típusa ugyan úgy mint a változóknak, a tömbök olyan típusú változókat tartalmaznak amilyen típusú a tömb, ezeken belül a tömb indexével tudunk mozogni. A mutató típust is átvesszük. A nevesített konstans egy olyan eszköz a programozásban aminek 3 része van: Név, Típus, Érték. Ezt a 3 at mindig deklarálni kell. Ugye a konstans jelentése álladnó, tehát ez a programban mindig a deklarálásnál megadott nevet, értéket és típust fogja tartalmazni. Ezeket érdemes beszélő nevekkel ellátni, és olyan értékeket adni amiket sokszor használunk. C ben ezt az alábbi módon kell: " #define név literál ". A változó a konstant "testvére" úgymond. Neki 4 komponense van, Név, attribútom, cím, érték. A váltózó ahogy a neve is mondja nem állandó. A név az azonosítója. ezzel hivatkozunk rá a programban. Az attríbutok közül a legfontosabb hogy milyen típusú, a típusokrol már fentebb beszéltünk, amilyen típusú olyan értéket tud tárolni. És tudun címet adni neki, azaz hol helyezkedjen el a tárolóban. de az elhelyezést a gép végzi, de hogy mikor hozza létre az attol függ hogy hol deklaráljuk . Nézünk egy pédát: int a=5 . ez egy egész tipusú váltózó kezdőértéke 5 a neve pedig "a". Most nézzük meg a C byelv alapelemeit. Vannak integrált típusok (int, char..stb). Származtatott típusok (tömb, függvény, union, mutató).Ezek az aritmetiaki típusok. A tömböt az alábbi módon hozzuk létre: int a[elemszám]. megadjuk a típusát a nevét és hogy hány elemű. Az utasítások a következő rész. Az utasítások alkotják a programot. Ezekblő épül fel egy algorítmus, ciklus, és szinte mindent, az utasításokat fordítja le a fordítóprogram tárgyprogramra. Kér nagyobb részre tudjuk bontani, deklarációs utasítáás és végrehajtható utasítás. A deklarációs utasítás a fordítóprogram miatt vannak. tőle kérnek szolgálltatást vagy egy üzzemmóbdba való lépést. Befolyásolja a tárgykódot de nem kerül lefordításra. A vegrehajtható utasítás, ahogy a nevében is benne van, bóvégre lehet hajtani.Ezekből lesz generálva a tárgykód. Ezeket tudjuk csoportosítani például értékeadó utasítás, üres utasítás, ugró utasítás, elágazó utasítás, hívó utasítás, I/O utasítások ...stb. Ezekről a könyvben részletes leírást kapunk. péladául az értékadó utasításban értéket adunk vagy modosítunk egy változón vagy több változón. Az elágazó utasítások is szinte kihagyhatatlanok egy programbol, ugye ezek az if és az else if feltételes utasítások. Ezek lehetővé teszik a programban a több irányú elágazást. A ciklusszervező utasításokat is ismerjük már ha nem kezdők vagyunk. Ugye ezek a for, while, do wile ciklusok. A végtelen ciklus volt az első feladatunk, azt már ismerjük, Vannak feltételes ciklusok, ugye itt addig fut a ciklus még a feltétel igaz. van kezdő feltételes ls végfeltételes ciklus.Ezeknek a működését a könyvben megismertük. Van az előírt lépésszamú ciklus (a for()). Annyiszor fut le a ciklus, ahányszor előírtuk neki. Vannak összetett ciklusok Ez az előzők kombinéciója. A működésük nagyon bonyolult. 3 vezérlő utasítás van C ben. 1. Return: Ez szabáylosan befejezzi a függvényt és vissza adja azt a vezérlést hívónak, legtöbbször értékkel tér vissza. 2. BREAK: ezt a cikluson belül alkalmazzuk, ha életbe lép akkor kilép a ciklusból és az utánna lévő cikluson belüli utasításokat nem hajtja végre. Ezt iffel szoktuk alkalmazi . 3. Continue: ez is a ciklus magban van. ez is kilép, vagy újabb cikluslépésbe kezd, vagy megvizsgálja újra az ismétlődés feltételeit. Az 5. fejezetben a programok szerkezetét ismerjük meg, hogy milyen részekből áll. Itt ismerjük meg az alprogram feladata egy bemeneti adatcsoport leképzése vagy kimeneti adatcsoportot kpez le, egy megadott specifikáció szerint. Ebben a fejezetben ismerjük megg a bklokkokat. a blokk egy programegység, ami utasításokat foglal magában. A kezdetét és végét speciális karakter jelzi. A blokk bárhol elhelyezhetó a programban. A 13. I/O fogjuk venni. Ez egy egy olyan rész ahol a program nyelvek nagyban eltérnek egymástól. Állimányuk a funkciók szerint 3 lehet. lehet input,output és input-output állomyán.
        Az I/O során a programban az adatok a tár és a periféria között mozognak. Ezeknek van egy bizonyos ébrázolási módja. Az adatátvietelnek 3 fajtáját alkalmazzuk: formátumos módú, szerkesztett modú és listázott modú adatátvietl. Ha állományokat alkalmazunk azt a következpképpen kell csinálnunk. 1. deklaráció,  2. összerendelés, 3. állomány megnyitása, 4. feldolgozás, 5. lezárás. A C-nyelvnek nem része az I/O erre egy standart könyvtárat használunk. 
        </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
       	<para>
        A könyvben a C nyelv alapjaival fogunk megismerkedni az alapoktól. A könyv programok segítségével segít elsajátítani a C nyelv ismeretét. Ha eddig egyátalán nem találkoztunk a C nyelvel, a könyv akkor is nagyon hasznos lehet, hiszen nagyon részletesen, mindenre odafigyelve adja át a tudást. Először kezdjük a változók típusaival és a program beli alkalmazásával. A programban különböző tipusú ezeken belül különbözű méretű változók vannak. Típusok: int -intiger, azaz egész típusú számot deklarálunk ezzel, mérete a gép egészétől függ. char -Ez egy karaktert tud tárolni, mérete 1 bájt. float - egyszeresen pontos lebegőpontos számot tud tárolni (törtet). double- kétszeresen pontos lebegőpontos számot tud tárolni, ezt hatalmas számokkal való számolásnál használjuk. Az int típustnak vannak fajtái még, ilyen a short int vagy a long int, van továbbá még unsigned int amivel a negatív számok helyett, csak pozitív értékeket tudunk tárolni, de abból többet mint a sima int-nél. Továbbá ami még lényeges lehet, az lokális és globális változó, ahogy a nevük is jelzi, a globális az egész programban használható, még a lokális csak a megadott helyen. A könyvben a helyes alkalmazásról rengeteg példát láthatunk. Vannak az állandók, ezeknek megadunk egy értéket, és ez az érték állandó lesz a programban, nem változik. A könyv következő fejezetében a Vezérlési szerkezetet vesszük.  Ez határozza meg , hogy milyen sorrendben hajtódnak végre a műveletek. Először az utasításokat és a blokkokat nézzük. Fontos szabály, hogy minden utasítást ";" -al zárunk le. Így válik egy sor utasítássá. Ha az utasítások {}-el vannak körbe zárva, akkor azt egy bloknak nevezzük és 1 db utasításlént kezeljük. A blokkok közé soroljuk a ciklusokat és a az elágazásokat. Először az if utasítással ismerkedünk meg. Ha a megadott feltétel igaz, akkor a megadott utasítások fognak lefutni, ha nem igaz akkor az utasításokat figyelmenkívűl hagyja. Ennek a bővítése az else-if. Itt meg tudjuk adni, hogy a program milyen utasításokat hajtson végre, ha a feltétel nem igaz. A következő a switch utasítás. A lényege hogy megadunk neki mintákat, és ha a vizsgált elem megegyezik valamelyik mintával, a mintánál megadott utasítások fognak lefutni. ezek után vegyük a ciklusókat. A ciklus egy olyan blok ami a feltételig újra és újra lefut. Kezdjük a while ciklussal, a while jelentése amíg, tehát amíg a kifejezés igaz addig lefut a ciklus, itt az lesz fontos, hogy először vizsgálja meg , hogy a feltétel igaz e, aztán fog lefutni az utasítás vagy utasítások. Ezzel megeggyezik a for utasítás, a lényege és működési elve ugyan ez. A felépítése különbözik. A do while ciklus először végrehajtja az utasítást és aztán vizsgálja meg a feltételt, ha nem igaz akkor kilép a ciklusból. A break utasíással a futás közben is kitudunk lépni egy ciklusból ezt a ciklusokban lévő if-ekben szoktok alkalmazni. A goto -val pedig egy adott cimkére ugorhatunk. De ezt nem sűrűn alkalmazzák, sokan nem is szeretik. Rendezni tudjuk ezeket a futási sorrend alapján. Van a sima ami sorban fut le, de van a cimkézett usasítás blokk az előbb említett goto-val, itt az adott feltételektőll függ, milyen sorrendben fut le a program. A Függelékben az utasításoknál csoportosítjuk az utasítások fajtáit. A címzett utasításokhot előtagként megadott cimke kapcsolódik. A kifejezésutasítás, a nevéből adódoan kifejezésekből épül fel. Az összetett utasítás megszünteti a korlátozást ahol a fordító csak egyetlen utasítást fogad el. A kiválasztó utasítások, a lehetséges esetek közül választ a feltételnek megfeleően (if, switch). A vezérlés átadó utasítások, amár fentiekben emlitett goto, continuem break, return parancsokat alkalmazza. Az Iterációs utasítások a ciklusokat alkalmazzák (while, do, for).
        </para>        
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
        A könyv témája a szoftverfejlesztés C++-ban. A legelső fejezetben azokat az új dolgokat fogjuk megnézni amiket C-ben nem tudtunk de C++ ban már lehetséges. Elsőre függvényparaméterek és visszatérési értékek vesszük. A C ben üres paraméterlistával definiált függvényt itt C++ ban void paraméter megadásával oldjuk meg.A visszatérési típusnál is eltér a 2 nyelv. Míg a C nyelvél int, addig C++ nem támpgatja az alapméretezett típust. Az int main fő függvénynek is 2 típusa van C++ -ban. Az első mikor nem adunk meg semmit, a másik mikor argumentumokat adunk a mainnak a parancssorból. A C++ nyelvben jelent meg előszőr a bool azaz a logikai típus aminek értéke true vagy false. A feladatok között van egy ahol az volt a hiba, mikor utasításon belül deklaráltunk. C++ ban már ez is lehetséges. A példa erre, hogy az i értéket a forcikluson belül deklaráljuk: "for(int i=0; i kisebb mint 10; i++)". Hasznos lehet, ha a deklarációt a felhasználás előtt végezzük. C++ ban a függvényeket a nevük és a megadott argumentumokkal azonosítjuk. Azonos nevű csak akkor lehet, ha más az argumentum lista. C-ben a paraméterátadás érték szerint történik. A megkapott érték klonózva lesz és a másolatra fogunk hivatkozni, azaz a visszatérési érték nem befolyásolja a programunkat. Ez az adott példában a könyv jól szemlélteti. Ennek C++ ban a megoldása hogy az eredeti változót fogjuk átadni mégpedig a memória címével. Ezt a referencia jellel fogjuk teljesíteni. Így a változtatások, az eredeti változón jatódnak végbe, és az új értéket kapja vissza a program. Ez a referencia C-ben nem létezik. A harmadik fejezetben megísmerjük az Objektumokat és osztályokat. A C++ nyelv egy objektumorientált nyelv, ennek alapelveivel megismerkedünk. A lényege hogy a függvényeket osztályokba foglaljuk az osztályok pédányait nevezzük objektumoknak. (objektumokkal hívjuk meg az osztályok függvényeit.) A 3.2 bekezdésben egy példán keresztül láthatjuk, az egységbezárás előnyeit. A struktúránknak így lesznek tagváltzói, és tagfüggvényei is. A tagfüggvényeket kétféle képpen adhatjuk meg. Osztálydefinícióban vagy struktúradefiníción kívül . Fontos még az adatrejtésről is beszélnünk. Így csak az osztályon belül férhetünk hozzá, külső osztály nem férhet hozzá, az értéket függvényel tudjuk kiadni. függvény és változó is lehet ilyen, ezeket a private részbe írjuk, azaz ezeket príváttá tesszük. A konstruktor onnan ismerjük fel, hogy ugyan az a neve mint az osztálynak és nem adunk típust neki, ez akkor fut le, ha meghívjuk az adott osztáylt amiben benne van, egy objektummal, ezt gakran inícializálásra használjuk. A destrukot annyiban különbözik színtaktikailag, hogy a név előtt egy '~' jel található, és autómatikusan meghívódik egy objektum befejeződésekor, ezt a memória felszabadításra szoktuk használni főként. A c-ben a dinamikus memóriafoglalás malloc-al vagy a free kulcsszavakkal történtek. A C++ ban már operátorral tudunk lefoglalni memóriát, ez a new operátor, példa: "int *pelda; pelda= new int;" később ezt a változót fel kell majd szabadítanunk, vagy memóriaszivárgás lép fel. A dinamikus adattámogatás miatt szükséges sokszor, hogy megadjuk a mutató állapotát. Ez a NULL kulcsszó. Ha az állapot NULL akkor nincsen lefoglalt adat, ha ezt nem adjuk meg akkor a new szócskával lefoglalt területre mutat. A 3.5.3 fejezetben ismerkedünk meg a másoló konstruktorral. A másolókunstruktor egy referenciát kap, amely megegyezik az osztálynak a típusával. A másolókonstruktor is rendelkezik mindennel, amivel egy egyszerű konstruktor. Ugyan úgy tudunk inicíalizálni vele objektumokat. Amiben viszont több hogy érték szerint adunk egy függvényparamétert neki, akkor a megadott változó lemásolódik, és ezt használjuk a függvény törzsében. Az osztályainknak lehetnek friend függvényei vagy osztélyai. Ez azt jelenti, hogy jogot adunk egy függvénynek vagy egy osztálynak, hogy hozzá férjen az adott osztály védett, azaz private és protected változóihoz és függvényeihez. Ezt a friend kulcsszóval tesszük lehetővé. A feljogosítandó függvény vagy osztály elé írjuk és ezzel fel is jogosítjuk. A tagváltozóknál az értékadás és az inicializálás nem ugyan az. Az inicializálás azaz alaphelyzetbe álltjuk. A létrehozásnál megadunk neki egy alap értéket. Az értékadás az az "=" jelel történik a programtol függően, ez a programon belül bárhol megtörténhet ahol a szabályok engedik. Említenünk kell a statikus tagokat, ezek a tagok az osztályhoz tartoznak és nem az osztályobjektumhoz. Továbbá lehetőségünk van struktúráknak, osztályoknak típusdefinícióra, a typedef  szóval.  A hatodik fejezetben vesszük az operátorokat és az operátortúlterhelést. A C nyelvben az operátorok műveleteket végeznek az argumentumokon. Az operátorok kiértékelési sorrendjét egy speciális szabályrendszer határozza meg, ezeket ugyan úgy mint matematikában, zárójelekkel írhatunk felül. A C++ rendelkezik új operátorokkal a C -hez képest. Ilyen a hatókör operátor aminek jelölése a "::" ezt az osztáylok hatólörének megadásánál használjuk. Ismerjük már a "*" operátor, ugye ezzel jelöljük a mutatókat. A "->" operátorral pedig mutató esetén hivatkozunk. Fontos különbség a C és a C++ között a függvénymellékhatása, A C nem képes erre, de a C++ igen. Ráadásul mivel az operátor speciális függvény ezért különböző argumetumok esetén túl tudjuk őket terhelni. A 10 es fejezet a kivitelezésről szól. Ilyen a hagyományos hibák kezelése. De mi is az a kivitelezés? A kivitelezés egy mechanizmus, amely ha hibát fedez fel, akkor a hibakezelő ágra ugrik. Ilyen a try_catch blokk. A throw kulcsal küldünk egy kidobást. a try-catch pedig elkapja, ha egy catch ág megegyezik az elkapott típussal. Ha nem kapja el, azt kezeletlen kivitelnek nevezzük. Van egymásba ágyazott try-catch blokk, így tudjuk a kidobásokat külön szinten kezelni
        </para>  
    </section>        
</chapter>                

